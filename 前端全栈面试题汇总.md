 



#  3261.自我介绍

```
2分钟，200-300个字，主旨自己基本情况，工作经历，优点，兴趣爱好，职业规划，邀约
```

# 2.vue面试题

1.v-show和v-if区别

```
v-show通过css display控制显示和隐藏，v-if组件真正的渲染和销毁，而不是显示和隐藏，频繁切换状态使用v-show 否则v-if
```

2.为何v-for要用key

```
快速查找到节点，减少渲染次数，提升渲染性能
```

3.描述vue组件声明周期

```
单组件声明周期图
挂载： beforeCreate => created => beforeMount => mounted
更新： beforeUpdate => updated
销毁： beforeDestroy => destroyed

父子组件生命周期图
挂载： parent beforeCreate => parent created => parent beforeMount => child beforeCreate => child created => child beforeMount => child mounted => parent mounted
更新： parent beforeUpdate => child beforeUpdate => child updated => parent updated
销毁： parent beforeDestroy => child beforeDestroy => child destroyed => parent destroyed
从以上能够看出：
挂载时，子组件是在父组件before mount后开始挂载，并且子组件先mounted，父组件随后
更新时，子组件是在父组件before update后开始更新，子组件先于父组件更新
销毁时，子组件是在父组件before destroy后开始销毁，并且是子组件先销毁，父组件随后。
```

4.vue组件如何通信

```
1.父子组件props和this.$emit
2.ref 链：父组件要给子组件传值，在子组件上定义一个 ref 属性，这样通过父组件的 $refs 属性就可以获取子组件的值了，也可以进行父子，兄弟之间的传值($parent / $children与 ref类似)
3.事件总线bus：使用一个 空的 VUE 实例作为事件总线，自定义事件event.$on   event.$off  event.$emit
4 provide  inject组件通信
5.vuex
6.$attrs和$listeners 仅仅是传递数据，而不做中间处理，$attrs 里存放的是父组件中绑定的非 Props 属性，$listeners里存放的是父组件中绑定的非原生事件。

常见使用场景可以分为三类：
父子通信：
	父向子传递数据是通过 props，子向父是通过 events（$emit）；
	通过父链 / 子链也可以通信（$parent / $children）；
	ref 也可以访问组件实例；
	provide / inject API；
	$attrs/$listeners
	vuex
兄弟通信：
	事件总线Bus；
	Vuex
跨级通信：
	事件总线Bus；
	Vuex；
	provide / inject API
	$attrs/$listeners
```

5.描述组件渲染和更新的过程

```
1、vue 组件初次渲染过程
解析模板为 render 函数
触发响应式，监听 data 属性的 getter 和 setter
执行 render 函数， 生成 vnode，patch(elem,vnode)
2、vue 组件更新过程
修改 data， 触发 setter （此前在getter中已被监听）
重新执行 render 函数，生成 newVnode，patch(vnode, newVnode)
```

6.双向数据绑定v-model的实现原理

```
双向数据绑定最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的.

先是从data里面的数据msg通过绑定到input控件和p标签上。然后input上通过v-on:input监听控件，触发change()。
调用方法都可以默认获取e事件，e.target.value是获取调用该方法的DOM对象的value值。把value值在赋给data里的msg，就是实现了双向数据绑定的原理了。

```

7.对mvvm的理解

```
m->model,v->view,vm->viewModel。dom通过监听事件操作vue里的data，反之vue中的data通过指令操作dom，这就是所说数据驱动视图，这就是mvvm的理解。
```

8.computed有何特性

```
缓存，data不变不会重新计算，提高性能
```

9.VUE 中如何封装组件？什么组件，为什么要封装组件？组件中 data 为什么是一个函数？

```
   为什么要封装组件？
　　主要就是为了解耦，提高代码复用率。
　　什么是组件？
　　页面上可以复用的都称之为组件 它是 HTML、CSS、JS 的聚合体。
　　组件就相当于库，把一些能在项目里或者不同项目里可以复用的代码进行需求性的封装。
　　组件中的 data 为什么是一个函数？
　　让每个返回的实例都可以维护一份被返回对象的独立的拷贝。
```

10.ajax请求应该放在哪个生命周期？

```
mounted，因为js是单线程，ajax异步获取数据
```

11.如何将组件所有props传递给子组件？

```
父组件绑定一个自定义属性变量，然后子组件通过props使用这个变量即可。
```

12.如何自定实现v-model?

```
我们定义了model对象。model对象包含两个属性，一个是prop，一个是event。prop值text1，event的值change1，我们这里写model是为了改变默认的东西，使用我们自己定义的变量。
<input type="text"  :value="text1"   @input="$emit('change1', $event.target.value)" >
```

13.多个组件有相同逻辑，如何抽离？

```
使用mixin 对公共部分的逻辑进行抽离
```

14.何时要使用异步组件？

```
加载大组件，路由异步加载
```

15.何时使用keep-alive？

```
缓存组件不需要重复渲染，多个静态tab页切换，优化性能
```

16.何时使用beforeDestroy？

```
1.解绑自定义事件event.$off
2.清除定时器
3.解绑自定义dom事件，如windom.scroll等
```

17.什么是作用域插槽？

```
在solt组件中有自己的data，把它传给使用的地方
```

18.vuex中action和mutation有何区别？

```
action中处理异步，mutation不可以
mutation做原子操作，action2可以整合多个mutation
```

19.vue-router常用路由模式

```
hash默认，h5 histroy需要服务端支持
```

20.如何配置vue-router异步加载

```
component:() => import('./component')
```

21.请用vnode描述一个dom结构

```
<ul id='test'>
	<p class='hehe'>这里是p标签</p>
	<li>{{1+1}}</li>
</ul>
let vdom={
    tag:'ul',
    props:{
    	id:'test'
    },
    children:[
    	{
    		tag:'p',
    		props:{
    			class:'hehe'
    		},
    		children:'这里是p标签'
    	},
    	{
    		tag:'li',
    		children:1
    	}
    ]
}
```

22.监听data变化的核心api是什么？

```
vue2.0核心api是Object.defineProperty，vue3.0是启用provy实现响应式
```

23.vue如何监听数据变化？

```
vue中的watch监听数据变化
```

24.请描述响应式原理？

```
1.描述监听data变化
监听对象变化：vue2.0核心api是Object.defineProperty，vue3.0是启用provy实现响应式
监听数组变化：重写数组的push.pop.shift.unshift.splice.sort.reverse方法
2.组件渲染和更新的过程(面试题5)
```

25.简述diff算法过程（了解）

```
在执行Diff算法的过程就是调用名为 patch 的函数，比较新旧节点。一边比较一边给真实的 DOM 打补丁。patch 函数接收两个参数 oldVnode 和 Vnode，它们分别代表新的节点和之前的旧节点。这个patch函数会比较 oldVnode 和 vnode 是否是相同的, 即函数 sameVnode(oldVnode, vnode), 根据这个函数的返回结果分如下两种情况：
true：则执行 patchVnode
false：则用 vnode 替换 oldVnode
//对比过程
找到对应的真实 dom，称为 el
判断 vnode 和 oldVnode 是否指向同一个对象。
如果是，那么直接 return。
如果他们都有文本节点并且不相等，那么将 el 的文本节点设置为 vnode 的文本节点。
如果 oldVnode 有子节点而 vnode 没有，则删除 el 的子节点。
如果 oldVnode 没有子节点而 vnode 有，则将 vnode 的子节点真实化之后添加到 el
如果两者都有子节点，则执行 updateChildren 函数比较子节点。
```

26.vue为何是异步渲染，$nextTick何用？

```
因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以考虑性能问题，Vue会在本轮数据更新之后，再去异步更新视图
$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM
```

27.vue常见性能优化方式？

```
1.合理使用v-if和v-show，
2.合理使用computed，
3.v-for加key，
4.自定义事件，dom事件及时销毁，
5.合理使用异步组件，
6.合理使用keepalive，
7.data层级不要太深，
8.使用vue-loader在开发环境做模板编译，
9.前端通用性能优化（如图片懒加载/减少 HTTP请求数/合理设置 HTTP缓存/资源合并与压缩/合并 CSS图片/将 CSS放在 head中/避免重复的资源请求/切分到多个域名），
10.使用ssr
```

 28、VUEX 是什么？怎么使用？那种场合能用？

```
vuex 是一个专门为 vue 构建的状态管理工具，主要是为了解决 多组间之间状态共享问题。强调的是集中式管理，（组件与组件之间的关系变成了组件与仓库之间的关系）
　　vuex 的核心包括：state（存放状态）、mutations（同步的更改状态）、actions（发送异步请求，拿到数据）、getters（根据之前的状态派发新的状态）、modules（模块划分）
　　state 发布一条新的数据，在 getters 里面根据状态派发新的状态，actions 发送异步请求获取数据，然后在 mutations 里面同步的更改数据
　　应用场合：购物车的数据共享、登入注册
```

29、vue 的指令用法

```text
v-html   //html
v-text   //元素里要显示的内容
v-bind：data    //绑定动态数据   ：data
v-on：click      //绑定事件       @click
v-for
v-if　　 //条件渲染指令
v-model    //双向绑定，用于表单
```

30、vue.js的两个核心是什么？

```
数据驱动和组件化
```

31.vue中子组件调用父组件的方法?

```
1.直接在子组件中通过this.$parent.event来调用父组件的方法。
2.在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。
3.父组件把方法传入子组件中，在子组件里直接调用这个方法。
```

32.vue中父组件调用子组件的方法?

```
父组件利用ref属性操作子组件方法。
父：
<child ref="childMethod"></child>
子：
method: {
  test() {
     alert(1)
  }
}
在父组件里调用test即 this.$refs.childMethod.test()
```

33.vue页面级组件之间传值?

```
    1.使用vue-router通过跳转链接带参数传参。
    2.使用本地缓存localStorge。
    3.使用vuex数据管理传值
```

34.说说vue的动态组件。

```
 多个组件通过同一个挂载点进行组件的切换，is的值是哪个组件的名称，那么页面就会显示哪个组件。
```

35.$route和 $router的区别是什么？

```
 $router为VueRouter的实例，是一个全局路由对象，包含了路由跳转的方法、钩子函数等。
 $route 是路由信息对象||跳转的路由对象，每一个路由都会有一个route对象，是一个局部对象，包含path,params,hash,query,fullPath,matched,name等路由信息参数。
```

36.为什么使用vue开发？

```
组件化开发 单页面路由 丰富的Api方法 双向的数据绑定 单向数据流 易于结合其他第三库
```

37.vue和react 有什么区别？

```
1、监听数据变化的实现原理不同**
2、数据流的不同**
3、HoC和mixins**
4、组件通信的区别**
5、模板渲染方式的不同**
6、渲染过程不同**
7、框架本质不同**
```

38.Vuex和Redux的区别

```
mvvm和mvc理解 与区别？
View 将请求转交---> Controlle  处理 --->Model数据更新保存 ----->View视图显示
View 接受用户交互请求
View 将请求转交给Controller处理
Controller 操作Model进行数据更新保存
数据更新保存之后，Model会通知View更新
View 更新变化数据使用户得到反馈 
MVVM即Model-View-ViewModel，将其中的 View 的状态和行为抽象化，让我们可以将UI和业务逻辑分开。MVVM的优点是低耦合、可重用性、独立开发。 
View 接收用户交互请求
View 将请求转交给ViewModel
ViewModel 操作Model数据更新
Model 更新完数据，通知ViewModel数据发生变化
ViewModel 更新View数据 
```

39.说一下vue的生命周期/钩子函数都有哪些？

```
单组件声明周期图
挂载： beforeCreate => created => beforeMount => mounted
更新： beforeUpdate => updated
销毁： beforeDestroy => destroyed

父子组件生命周期图
挂载： parent beforeCreate => parent created => parent beforeMount => child beforeCreate => child created => child beforeMount => child mounted => parent mounted
更新： parent beforeUpdate => child beforeUpdate => child updated => parent updated
销毁： parent beforeDestroy => child beforeDestroy => child destroyed => parent destroyed
从以上能够看出：
挂载时，子组件是在父组件before mount后开始挂载，并且子组件先mounted，父组件随后
更新时，子组件是在父组件before update后开始更新，子组件先于父组件更新
销毁时，子组件是在父组件before destroy后开始销毁，并且是子组件先销毁，父组件随后。
```

```
钩子函数有三种 ,也叫路由守卫
全局导航钩子（跳转前进行判断拦截）  全局路由守卫
router.beforeEach(to, from, next),全局前置守卫
router.beforeResolve(to, from, next),全局的解析守卫
router.afterEach(to, from ,next) 全局的后置守卫
组件内钩子    路由独享的守卫
beforeRouteEnter
beforeRouteUpdate
beforeRouteLeave 
单独路由独享组件
beforeEnter   组件内的守卫
```

40.双向数据绑定的理解？

```
vue采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty劫持data属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
```

41.vue组件中data为什么函数返回一个对象

```
组件中的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的data。如果单纯的写成对象形式，就使得所有组件实例共用了一份data，造成了数据污染。
```

42.vue中哪些数组方法可以直接对数组修改实现视图更新

```
push() pop() shift() unshift() splice() sort() reverse() vue数组对象修改触发视图更新
```

43.有哪些指令？v-if和v-show区别，v-if、v-for优先级

```
v-html   //html
v-text   //元素里要显示的内容
v-bind：data    //绑定动态数据   ：data
v-on：click      //绑定事件       @click
v-for
v-if　　 //条件渲染指令
v-model    //双向绑定，用于表单

v-show通过css display控制显示和隐藏，v-if组件真正的渲染好饿销毁，而不是显示和隐藏，频繁切换状态使用v-show 否则v-if
v-for和v-if不应该一起使用，必要情况下应该替换成computed属性。原因：v-for比v-if优先，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候。
```

44.v-for中key 的作用

```
快速查找到节点，减少渲染次数，提升渲染性能
```

45.使用过keep-alive吗

```
keep-alive缓存vue实例，提高性能是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，
提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高； 
对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。
```

46.computed、watch（自动监听、深度监听）、methods区别

```
我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的。
不同点：
computed：计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值。
methods：只要发生重新渲染， method 调用总会执行该函数。
watch监听对象需要深度监听，默认是浅监听
当页面中有某些数据依赖其他数据进行变动的时候，可以使用计算属性computed。 
watch用于观察和监听页面上的vue实例，如果要在数据变化的同时进行异步操作或者是比较大的开销，那么watch为最佳选择。
```

47.vue中对象更改检测的注意事项

```
由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：
对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 `Vue.set(object, key, value)`方法向嵌套对象`添加响应式属性`。为已有对象赋予多个新属性，比如使用 `Object.assign()`或 `_.extend()`。在这种情况下，你应该用两个对象的属性创建一个新的对象。
```

48.什么是$nextTick？

```
场景：vue是异步渲染的框架，react也是，data改变之后，dom不会立刻渲染，$nextTick会在dom渲染之后被触发，以获取最新dom节点
```

49.ref 的作用？

```
获取dom元素 this.$refs.box
获取子组件中的data this.$refs.box.msg
调用子组件中的方法 this.$refs.box.open()
```

50.什么是vuex？vuex核心包括？怎么修改state中数据？在项目中哪里使用？

```
vuex 是一个专门为 vue 构建的状态管理工具，主要是为了解决 多组间之间状态共享问题。强调的是集中式管理，（组件与组件之间的关系变成了组件与仓库之间的关系）
　　vuex 的核心包括：state（存放状态）、mutations（同步的更改状态）、actions（发送异步请求，拿到数据）、getters（根据之前的状态派发新的状态）、modules（模块划分）
　　state 发布一条新的数据，在 getters 里面根据状态派发新的状态，actions 发送异步请求获取数据，然后在 mutations 里面同步的更改数据
　　应用场合：购物车的数据共享、登入注册
```

51.路由模式有哪些？路由传参有哪些方式？路由守卫有哪些，有没有在项目中使用过？

```
hash模式（默认） 例如：http://abc.com/#/user/10
h5 history模式  例如：http://abc.com/user/20 需要server端支持
注意：history有如下问题 404

路由传参方法？
query传参和params传参
```

```
1、声明式导航
不带参跳转 对应的地址为/foo
url字符串拼接传参 对应的地址为/foo?id=123
query方式对象形式传参 对应的地址为/foo?id=123
params方式对象形式传参 对应地址为 /path/123 , 注意params和query一起使用params会失效，params与name一起使用
2、编程式导航(路由实例对象router=new VueRouter())
字符串router.push('home')
对象router.push({ path: 'home' })
命名的路由 对应路径为/path/123
router.push({ name: 'user', params: { userId: '123' }})
带查询参数，变成 /register?plan=123
router.push({ path: 'register', query: { plan: '123' }})

接收参数
this.$route.params.id
this.$route.query.xxx
```

52.vue过滤器

```
过滤器是将后台返回的数据换一种形式输出，不改变原来的数据 应用场景:后台返回的状态码（性别，支付状态），商品价格
1. 全局过滤器                                                         
Vue.filter('过滤器',对应的过滤器函数)
2.局部过滤器
通过在Vue实例上挂载filers添加过滤器，只能在当前组件内部使用
```

53.有没有封装过组件，封装过什么，怎么封装？注意点或有哪些原则？

```
怎么封装：
● 首先，使用Vue.extend()创建一个组件
● 然后，使用Vue.component()方法注册组件
● 接着，如果子组件需要数据，可以在props中接受定义
● 最后，子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法
```

注意点或有哪些原则？

```
data数据结构设计，或者问有哪些原则
原则：
1.用数据描述所有的内容
2.数据要结构化，易于程序操作，遍历，查找
3.数据要可扩展，以便增加新的功能
组件如何设计，有什么原则
原则：
1.从功能上拆分层次
2.尽量让组件原子化，一个组件只做一件事情
3.容器组件（只管数据，一般是顶级组件）和展示组件（只管显示视图）
```

54.移动端项目如何适配（rem）？

```
css3规定：1rem的大小就是根元素<html>的font-size的值。
   通过设置 根元素<html>的font-size的大小，来控制整个html文档内的字体大小、元素宽高、内外边距等，
   根据移动设备的宽度大小来实现自适应，不同的设备都展示一致的页面效果。
rem布局简单分析 分三步：
第一步：前端开发者首先拿到UI设计原型稿的宽度，750宽度，如 320px 或者640px或者750px;
第二步：增加脚本（设置根元素<html>字体大小）
第三步：css中使用rem单位；关键点：字体大小，元素宽高，内外边距一定是根据设计稿测量得来的。
```

55.有没有使用过axios、axios拦截器，跨域如何解决？

```
axios拦截器：
// 添加请求拦截器
axios.interceptors.request.use
// 添加响应拦截器
axios.interceptors.response.use

跨域特别注意两点：
第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，
第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。
vue如何解决跨域：
proxyTable   这里vue脚手架生成的标准项目为准。一般在项目config目录下面有个index文件
CORS   CORS即跨源资源共享，它定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。
Nginx  当我们明白跨越的含义之后。只要解决了'源'的问题。那么跨越也就不存在了
```

56.vue项目做过哪些优化

```
（1）代码层面的优化 
v-if 和 v-show 区分使用场景
computed 和 watch  区分使用场景
v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
长列表性能优化
事件的销毁 addEventlisenter 事件监听
图片资源懒加载
路由懒加载
第三方插件的按需引入
优化无限列表性能
服务端渲染 SSR or 预渲染
（2）Webpack 层面的优化
Webpack 对图片进行压缩
减少 ES6 转为 ES5 的冗余代码
提取公共代码
模板预编译
提取组件的 CSS
优化 SourceMap
构建结果输出分析
Vue 项目的编译优化 
（3）基础的 Web 技术的优化
开启 gzip 压缩
浏览器缓存
CDN 的使用
使用 Chrome Performance 查找性能瓶颈
```

57.为什么做首屏优化？

```
首屏时间的快与慢，直接影响到了用户对网站的认知度。所以首屏时间的长短对于用户的滞留时间的长短、用户转化率都尤为重要。
```

58.如何做首屏优化？

```
css模块化加载，对应模块下的css交给js或jsonp请求返回
js懒执行，有交互才执行
图片在其他屏（非首屏）都采用懒加载的模式，这样既能节省流量，也能减少请求数或延迟请求数。
服务器方面：

1. 少量静态文件的域名，图片与iconfont均是放在同一个域下，减少DNS的解析事件，最好做到域名收敛。
2. 模块化接口的支持。
3. 首屏内容最好做到静态缓存
4. 对于vue和react做ssr
```

59.vue常用的修饰符

```
.stop - 调用 event.stopPropagation()，禁止事件冒泡。
.prevent - 调用 event.preventDefault()，阻止事件默认行为。
.capture - 添加事件侦听器时使用 capture 模式。
.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。
.native - 监听组件根元素的原生事件。
.once - 只触发一次回调。

v-model 指令常用修饰符：
.number - 输入字符串转为数字
.trim - 输入首尾空格过滤
.lazy
```

60.v-on可以监听多个方法吗？

```
v-on可以监听多个方法，但是同一种事件类型的方法，vue-cli工程会报错
```

61.vue中编写可复用的组件(深度好题，掌握思路,不用背诵)

1.在 Vue 组件中，状态称为 props，事件称为 events，片段称为 slots。

```
Props 允许外部环境传递数据给组件
Events 允许组件触发外部环境的副作用 $emit
Slots 允许外部环境将额外的内容组合在组件中。
组件的构成部分也可以理解为组件对外的接口。良好的可复用组件应当定义一个清晰的公开接口。
```

2.组件间通信

```
在 Vue.js 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。
```

3.命名

```
组件的命名应该跟业务无关。应该依据组件的功能为组件命名。
```

4.业务数据无关

```
可复用组件只负责 UI 上的展示和一些交互以及动画，如何获取数据跟它无关，因此不要在组件内部去获取数据，以及任何与服务端打交道的操作。可复用组件只实现 UI 相关的功能。
```

 5.组件职责

```
约束好组件的职责，能让组件更好地解耦，知道什么功能是组件实现的，什么功能不需要实现。
组件可以分为通用组件（可复用组件）和业务组件（一次性组件）。
可复用组件实现通用的功能（不会因组件使用的位置、场景而变化）：
UI 的展示
与用户的交互（事件）
动画效果
业务组件实现偏业务化的功能：
获取数据
和 vuex 相关的操作
埋点
引用可复用组件
可复用组件应尽量减少对外部条件的依赖，所有与 vuex 相关的操作都不应在可复用组件中出现。
组件应当避免对其父组件的依赖，不要通过 this.$parent 来操作父组件的示例。父组件也不要通过 this.$children 来引用子组件的示例，而是通过子组件的接口与之交互。
```

6.命名空间

```
可复用组件除了定义一个清晰的公开接口外，还需要有命名空间。 modules
命名空间可以避免与浏览器保留标签和其他组件的冲突。特别是当项目引用外部 UI 组件或组件迁移到其他项目时，命名空间可以避免很多命名冲突的问题。
```

7.上下文无关

```
还是上面那句话，可复用组件应尽量减少对外部条件的依赖。没有特别需求且单个组件不至于过重的的前提下，不要把一个有独立功能的组件拆分成若干个小组件。
```

8.数据扁平化

```
每个 prop 应该是一个简单类型的数据。这样做有下列几点好处：
组件接口清晰
props 校验方便
当服务端返回的对象中的 key 名称与组件接口不一样时，不需要重新构造一个对象

```

9.使用自定义事件实现数据的双向绑定  v-model

```
有时候，对于一个状态，需要同时从组件内部和组件外部去改变它。
:value   oninput
例如，模态框的显示和隐藏，父组件可以初始化模态框的显示，模态框组件内部的关闭按钮可以让其隐藏。一个好的办法是，使用自定义事件改变父组件中的值  
```

10.使用自定义 watch 优化 DOM 操作

```
在开发中，有些逻辑无法使用数据绑定，无法避免需要对 DOM 的操作。例如，视频的播放需要同步 Video 对象的播放操作及组件内的播放状态。可以使用自定义 watch 来优化 DOM 的操作。
```

11.项目骨架

```
单组件不异过重，组件在功能独立的前提下应该尽量简单，越简单的组件可复用性越强。当你实现组件的代码，不包括CSS，有好几百行了（这个大小视业务而定），那么就要考虑拆分成更小的组件。
```

62.vue如何监听键盘事件中的按键？（大声朗读2遍）

```
在我们的项目经常需要监听一些键盘事件来触发程序的执行，而Vue中允许在监听的时候添加关键修饰符：
<input v-on:keyup.13="submit">
对于一些常用键，还提供了按键别名：
<input v-on:keyup.13="submit">
全部的按键别名：
.enter
.tab
.delete (捕获“删除”和“退格”键)
.esc
.space
.up
.down
.left
.right
修饰键：
.ctrl
.alt
.shift
.meta
与按键别名不同的是，修饰键和 keyup 事件一起用时，事件引发时必须按下正常的按键。换一种说法：如果要引发 keyup.ctrl，必须按下 ctrl 时释放其他的按键；单单释放 ctrl 不会引发事件
<!-- 按下Alt + 释放C触发 -->
<input @keyup.alt.67="clear"> 
<!-- 按下Alt + 释放任意键触发 -->
<input @keyup.alt="other">
<!-- 按下Ctrl + enter时触发 -->
<input @keydown.ctrl.13="submit">
对于elementUI的input，我们需要在后面加上.native, 因为elementUI对input进行了封装，原生的事件不起作用。
<input v-model="form.name" placeholder="昵称" @keyup.enter="submit">
<el-input v-model="form.name" placeholder="昵称" @keyup.enter.native="submit"></el-input>
```

63.解决非工程化项目初始化页面闪动问题(好题,理解)

```
vue页面在加载的时候闪烁花括号{}，v-cloak指令和css规则如[v-cloak]{display:none}一起用时，这个指令可以隐藏未编译的Mustache标签直到实例准备完毕。{{name}}    data:  name:''
/*css样式*/
[v-cloak] {
      display: none;
    }
<!--html代码-->
<div id="app" v-cloak>
    <ul>
      <li v-for="item in tabs">{{item.text}}</li>
    </ul>
  </div>
```

64.v-for产生的列表，实现active的切换 tab切换

```
v-for生成序列
<ul>
    <li v-for="(info,index) in list" :key="info.id" @click="select(index)" v-bind:class="{'active':info.active}">{{info.name}}</li>
</ul>

data数据
list:[
        {
          name:'a',
          id:1,
          active:false
        },
        {
          name:'b',
          id:2,
          active:false
        },
        {
          name:'c',
          id:3,
          active:false
        },
        {
          name:'d',
          id:4,
          active:false
        },
      ]
点击事件
select(d){
      this.list.map(s=>s.active=false); //for  forEach  map  filter some
      this.list[d].active=true;
    },
CSS样式
<style scoped>
li.active{
  background-color: red;
 }
```

65.v-model语法糖使用

```
v-model语法糖  v-model其实是一种简写方式，我们常见的有两种v-model，分别是input元素上的v-model 和非input元素上v-model
input元素上的：
      <input v-model="price"><!-- 下行的语法糖 -->
      <input :value="price" @input="price = $event.target.value">
     
      data(){
        return {
          price: 20
         }
      }
 非input元素上的：
 Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  template: `
    <input
      type="checkbox"
      v-bind:checked="checked"
      v-on:change="$emit('change', $event.target.checked)"
    >
  `
})
父组件：<base-checkbox v-model="lovingVue"></base-checkbox>
```

66.十个常用的自定义过滤器

```
（1）去除空格  
	type:1-所有空格  2-前后空格  3-前空格 4-后空格。
（2）任意格式日期处理
（3）字母大小写切换
	type:1:首字母大写 2：首页母小写 3：大小写转换 4：全部大写 5：全部小写
（4）字符串循环复制,count->次数.
（5）字符串替换
（6）字符替换*，隐藏手机号或者身份证号等
（7）格式化处理字符串
（8）现金额大写转换函数
（9）保留2位小数   0.3 + 0.9 ！= 1.2  
（10）补零
```

67.vue等单页面应用及其优缺点

```
单页面应用（SPA），通俗一点说就是指只有一个主页面的应用
单页面的优点：
   用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小。
   前后端分离。
   效果会比较炫酷（比如切换页面内容时的专场动画）。
单页面缺点：
  不利于seo。
  导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）。
  初次加载时耗时多。
  页面复杂度提高很多。
```

68.vue的计算属性，特性，应用

```
含义：computed  是计算属性，把模板中的一些稍微复杂的逻辑计算放回到js代码中，解决在模板中放入太多的逻辑会让模板过重且难以维护的问题。
computed特性：
    （1）computed 是基于它们的依赖进行缓存的
    （2）只有在它的相关依赖发生改变时才会重新求值
computed应用：就是简化tempalte里面{{}}计算和处理props或$emit的传值
```

69.vue父组件向子组件通过props传递数据

```
父组件传递：
    <子组件调用  v-bind:自定义属性名="要传递的数据"></子组件调用>
子组件接收：
    props:['自定义属性名']
    props:{
    	type:String,
    	default{
    	  return ''
    	}
    }
```

70.vue-cli生产环境使用全局常量(了解)

```
第一步，在 static 下新建 config.js：
第二步，在 config.js 里面设置全局变量：
第三步，在 index.html 里面引入：
第四步，在其他 .js 文件中即可使用：
第五步，打包后修改：通过 `npm run build` 命令打包后，此 config.js 文件会被打包到 `dist/static`文件夹下，此时如果需要修改 `PUBLIC_IP`，打开`config.js`即可修改，无需重新打包！
```

71.vue弹窗后如何禁止滚动条滚动？（了解）

```
1.在有弹出框的页面中，加上以下方法，弹出框出现时调用禁止滚动方法stopScroll()，弹出框去掉是调取允许滚动方法canScroll()即可，代码如下

methods : {
  //禁止滚动
  stopScroll(){
    var mo=function(e){e.preventDefault();};
    document.body.style.overflow='hidden';
    document.addEventListener("touchmove",mo,false);//禁止页面滑动
  },
  /***取消滑动限制***/
  canScroll(){
    var mo=function(e){e.preventDefault();};
    document.body.style.overflow='';//出现滚动条
    document.removeEventListener("touchmove",mo,false);
  }
}

2.在全局js即main.js中，设置全局函数，在使用到的页面分别调用即可，代码如下：

//弹出框禁止滑动
Vue.prototype.stopScroll = function () {
 var mo = function (e) { e.preventDefault() }
 document.body.style.overflow = 'hidden'
 document.addEventListener('touchmove', mo, false)// 禁止页面滑动
}

//弹出框可以滑动
Vue.prototype.canScroll = function () {
 var mo = function (e) {
  e.preventDefault()
 }
 document.body.style.overflow = ''// 出现滚动条
 document.removeEventListener('touchmove', mo, false)
}
具体页面的调用方法如下：
 //当需要禁止弹出框底部内容滑动时调用：
 this.stopScroll()
 //当需要页面恢复滑动功能时调用：
 this.canScroll()
```

72.vue-cli中自定义指令的使用

```
1.全局注册
Vue.directive(‘name’, {})
2.局部注册
directives: {
  name: {}
}
然后在模版中直接使用即可。
```

73.父组件异步获取动态数据传递给子组件(好题)

```
问题：由于父组件中的数据是异步获取的，而子组件在一开始便会渲染，所以会造成子组件渲染完成后，数据还未获取到的情况
解决方案：在子组件渲染前，判断父组件数据是否获取完成，数据获取完成后再渲染子组件.
//tab-weekly(v-if="userId", :userId="userId")
//tab-weekly是子组件，userId是在父组件中异步获取、需要传递给子组件tab-weekly的数据，在其中加一个判断，//当userId存在后，再渲染子组件

```

74.父组件给子组件props传参，子组件接收的6种方法

```
1. data中  变量  = this.props里面的数据
2. watch监听  赋值
3. mounted  渲染完成后调用一个函数 进行赋值
4. vuex
5. computed 计算属性，用法和watch类似，computed是同步，watch可以异步
6. 父组件v-if 触发渲染和销毁，子组件触发传参
```

75.Vuex页面刷新数据丢失咋解决这个bug

```
问题：F5页面刷新，页面销毁之前的资源，重新请求，因此写在生命周期里的vuex数据是重新初始化，无法获取的，这也就是为什么会打印出空的原因。
解决思路1：
使用Localstorage sessionStorage 或cookie
实际使用时当vuex值变化时，F5刷新页面，vuex数据重置为初始状态，所以还是要用到localStorage, 
解决方法2:
插件vuex-persistedstate
vuex-persistedstate默认持久化所有state，可以指定需要持久化的state

```

76.按钮权限怎么做？

```
 在点击左侧菜单，存储全部权限，每次点击单个时候，去计算获取当前页面的按钮权限，封装一个button组件，然后在需要的地方引用
```

77.完整的说下从url解析到显示页面过程，结合项目中说

```
1. 首先浏览器主进程接管，开了一个下载线程。
2. 然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。
3. 将下载完的内容转交给Renderer进程管理。
4. Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。
5. 解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。
6. css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。
7. 绘制结束后，关闭TCP连接，过程有四次挥手
```

78.vue声明周期都在哪些场景中使用？

```
1.beforeCreate(){}
　　创建前，访问不到data当中的属性以及methods当中的属性和方法，可以在当前生命周期创建一个loading，在页面加载完成之后将loading移除
2.created(){}
　　创建后，当前生命周期执行的时候会遍历data中所有的属性，给每一个属性都添加一个getter、setter方法,将data中的属性变成一个响应式属性
3. beforeMount(){}
　　 模板与数据进行结合，但是还没有挂载到页面上。因此我们可以在当前生命周期中进行数据最后的修改
4.mounted(){}
　　当前生命周期数据和模板进行相结合，并且已经挂载到页面上了，因此我们可以在当前生命周期中获取到真实的DOM元素
5. beforeUpdate(){}
　　当数据发生改变的时候当前生命周期就会执行，因此我们可以通过当前生命周期来检测数据的变化
　　当前生命周期执行的时候会将更新的数据与模板进行相结合，但是并没有挂载到页面上，因此我们可以在当前生命周期中做更新数据的最后修改
6.updated(){}
　　数据与模板进行相结合，并且将更新后的数据挂载到了页面上。因此我们可以在当前生命周期中获取到最新的DOM结构
7. beforeDestroy(){}
　　当前生命周期中我们需要做事件的解绑  监听的移除  定时器的清除等操作
8. destroyed(){}
　　当前生命周期执行完毕后会将vue与页面之间的关联进行断开
当<keep-alive>包裹动态组件的时候会触发两个新的生命周期
9.　　activated     当组件为活跃状态的时候触发(活跃状态：进入页面的时候)
10.  deactivated     缓存状态的时候触发
```



# 3.html、css面试题

#### **1.html5有哪些新特性、移除了哪些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？HTML5是构建web内容的一种语言描述方式，在08年正式发布，12年已形成了稳定的版本。**

H5新特性有：

```
语义标签、增强型表单、Canvas绘图、地理定位、SVG绘图、拖放API、WebWorker、WebStorage、WebSocket
```

移除了：

```
 1、显现层元素：basefont 、big、center、font、s、strike、tt、u
 2、性能较差元素：frame、frameset、noframes
```

处理h5新标签的浏览器兼容性问题：

```javascript
方法一 :
1、使用静态资源的html5shiv包
<!--[if lt IE9]>
<script src="http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js"></script>
<![endif]-->
方法二：
IE6/IE7/IE8支持通过document方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签
```

如何区分HTML和HTML5：

```
1，文档的类型声明不同
HTML的代码很长。而H5的声明代码很简单
2，在语义结构方面
HTML：没有结构语义化标签（通俗来讲就是不方便阅读，没有告诉你哪里是头，哪里是尾）
H5：添加了许多具有语义化的标签，使代码解构清晰，提高了代码的可读性。
```

#### 2.行内元素和块级元素的区别？什么是重绘和回流？

```
行内元素：
共占一行，与其他行内元素并排，不能设置宽高，默认的宽度就是文字的宽度，行内元素只能嵌套包括自己在内的所有行内元素；a/b/i/u/em/strong/font/del/strike/span
块级元素：
独占一行，不能与其他任何元素并列，可以设置宽h/p/ul/ol/li/dl/dd/dt/table/caption/tr/th/td/tbody/tfoot/thead/div
```

回流：

```
当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。
```

重绘：

```
当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，则就称为重绘。
区别：
回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流
当页面布局和几何属性改变时就需要回流
```

#### 3.CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？CSS 选择符有哪些？

```
1.id选择器（#id）
2.类选择器（.class）
3.标签选择器（div，h1，p）
4.相邻选择器（h1 + p）
5.子选择器（ul > li）
6.后代选择器（li a）
7.通配符选择器（ * ）
8.属性选择器（a[title]）
9.伪类选择器（a:hover，li:nth-child）
```

**优先级算法如何计算？**

```
1.优先级就近原则，同权重情况下样式定义最近者为准；
2.载入样式以最后载入的定位为准；
3.!important > id > class > tag；
4.important 比 内联优先级高，但内联比id要高；
1、第一等：代表内联样式，如: style=””，权值为1000。
2、第二等：代表ID选择器，如：#content，权值为0100。
3、第三等：代表类，伪类和属性选择器，如.content，权值为0010。
4、第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。
5、通配符、子选择器、相邻选择器等的。如*、>、+,权值为0000。
6、继承的样式没有权值。
```

#### 4.CSS3有哪些新特性？

```
word-wrap 文字换行
text-overflow 超过指定容器的边界时如何显示
text-decoration 文字渲染
text-shadow文字阴影
gradient渐变效果
transition过渡效果 transition-duration：过渡的持续时间
transform拉伸，压缩，旋转，偏移等变换
animation动画
```

#### 5.解释盒模型宽高值得计算方式，边界塌陷，负值作用，box-sizing概念？

```
在盒模型中，有个问题免不了存在，边界塌陷。两个盒子垂直方向设置外边距，会造成便捷塌陷，只保留一个，哪个值大保留哪个。
 注意： 
   浮动元素和绝对定位元素不会发生边界坍塌
   只有块级元素的垂直方向才存在margin合并的问题，再说一下margin负值向内部缩减，正值向外。
```

#### 6.简述flex布局

```
flex弹性布局，可以简便、完整、响应式地实现各种页面布局, 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）
flex-direction：决定主轴的方向
row（默认值）：主轴为水平方向，起点在左端。
row-reverse：主轴为水平方向，起点在右端。
column：主轴为垂直方向，起点在上沿。
column-reverse：主轴为垂直方向，起点在下沿。
flex-wrap：换行
nowrap（默认）：不换行。
wrap：换行，第一行在上方。
wrap-reverse：换行，第一行在下方。
flex-flow：flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。
justify-content：水平对齐方式
flex-start（默认值）：左对齐
flex-end：右对齐
center： 居中
space-between：两端对齐，项目之间的间隔都相等。
space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
align-items：垂直对齐方式
flex-start：交叉轴的起点对齐。
flex-end：交叉轴的终点对齐。
center：交叉轴的中点对齐。
baseline: 项目的第一行文字的基线对齐。
stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
```

#### 7.css 隐藏元素有哪几种方法？

css隐藏元素方法

```
display:none
Jquery：show(),hide(),toggle()方法就是通过改变display的值来实现变化效果的。 
visibility:hidden：
和display:none的区别在于，元素在页面消失后，占据的空间依旧会保留着，但是display:none不会，所以它只会导致浏览器重绘而不会回流，因此，visibility:hidden适用于那些元素隐藏后不希望页面布局发生变化的场景；
opacity:0  (透明度，元素本身不会隐藏，会引起重绘)
overflow:hidden
position: absolute： 把元素脱离文档流移出视觉区域，既不会影响布局，又能让元素保持可以操作。应用该属性后，主要就是通过控制方向（top,left,right,bottom），达到一定的值，离开当前页面。
clip-path（不常用）
```

position定位有哪些？

```
1、static（静态定位，不脱流）
2、flex（固定定位，脱流）
3、relative （相对定位，不脱流）
4、absolute（绝对定位，脱流）
5、sticky（粘性定位）
```

#### 8.BFC（Block Formatting Context） 是什么？应用？

```
是一个独立的渲染区域，通俗点BFC就是页面上的一个隔离的独立容器，容器里面的元素布局不受外界影响，同时也不会影响到外面的元素。
那么我们可以通过CSS为元素设置一些属性，来触发BFC,常用的方式有：
Float值不为none
Postion值不为relative和static
Overflow值为auto scroll和hidden
display值为inline-block
通过这几种方式，我们可以使用BFC来：
1、防止margin重叠2、清楚内部浮动3、消除文本环绕做出自适应两栏布局：
```

#### 9.解释下浮动和它的工作原理？清除浮动的方法（4种）

浮动为该元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。

浮动引起的问题：

```
父元素的高度无法被撑开，影响与父元素同级的元素
与浮动元素同级的非浮动元素（内联元素）会紧跟其后
若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构
```

清除浮动的方法：

```javascript
1, 添加额外标签
  在浮动元素末尾添加一个空的标签，
<div style="clear:both"></div>
优点：通俗易懂，容易掌握 
缺点：可以想象通过此方法，会添加多少无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦。 
2, 使用 br标签和其自身的 html属性 
<br clear="all" /> 
优点：比空标签方式语义稍强，代码量较少 
缺点：同样有违结构与表现的分离，不推荐使用 
3, 父元素设置 overflow：hidden
优点：不存在结构和语义化问题，代码量极少 
缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素；overflow:hidden会导致中键失效。 
4、父元素设置 overflow：auto 属性。同样IE6需要触发hasLayout，演示和3差不多 
优点：不存在结构和语义化问题，代码量极少 
缺点：多个嵌套后，firefox某些情况会造成内容全选；IE中 mouseover 造成宽度改变时会出现最外层模块有滚动条等，firefox早期版本会无故产生focus等。
5,使用:after 伪元素 
需要注意的是 :after是伪元素（Pseudo-Element），不是伪类（某些CSS手册里面称之为“伪对象”），很多清除浮动大全之类的文章都称之为伪类，不过csser要严谨一点，这是一种态度。由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 
.clearfix:after {content:" "; display:block; visibility:hidden; clear:both; } 
.clearfix { *zoom:1; }
优点：结构和语义化完全正确,代码量居中 
缺点：复用方式不当会造成代码量增加 
```

#### 10.**什么是外边距重叠？重叠的结果是什么？**

外边距不重叠的情况：

```
1）水平margin永远不会重合
2）设置了overflow属性(visible除外)的元素和它的子元素之间的margin不会重叠
3）设置了绝对定位（position:absolute）的盒模型，垂直margin不会被重叠，和子元素之间也不重叠
4）设置了display:inline-block的元素，垂直margin不会重叠，和子元素之间也不重叠
5）根元素(如HTML)与body的margin不会重叠
```



防止外边距重叠的方法：

```
1）元素绝对定位position:absolute;一般用在内层元素
2）内层元素加float:left;或display:inline-block;
3）外层元素用padding增加边距
4）外层元素设置overflow:hidden;
5）内层元素透明边框border:1px solid transparent;
```

#### 11.如何让一个盒子水平垂直居中

**1、** **如何让一个盒子水平垂直居中**

```
①定位：（常用方法,推荐）
position:absolute;
position:relative;
left:值;
top:值;
②display:table-cell;
③外边距：margin-left:值;
margin-top:值;
④margin:auto;（不兼容低版本的IE浏览器）
⑤弹性盒模型：display:flex;
justify-content:conter;
align-itens:center;
⑥用transform的属性translate平移，不仅能实现绝对居中同样的效果，也支持联合可变高度方式使用。
使用top:50%; left:50%;时，是以盒子的左上角为原点定位，是左上角的原点居中，但是元素本身并不居中。
transform：translate(-50%，-50%):分别向左向上移动自身长宽的50%，使其位于中心。
transform: translate(-50%,-50%)导致的像素模糊问题解决办法：
  /** 这 0.5px加或者减都可以 */
transform: translat(calc(-50% + 0.5 px), calc(-50% + 0.5 px))；
⑦用calc计算
```



#### 12.左右固定中间自适应 三栏布局（圣杯、双飞翼、弹性盒子...）

**圣杯布局：**

缺点：当面板的main部分比两边的子面板宽度小的时候，布局就会乱掉。

**双飞翼布局:**

```
与圣杯布局很像，也是全部往左浮动，但是在内容div里再嵌套一个div，设置子div的margin为左右div预留位置，左右div只设置margin负值即可实现。
 相似点：
1.给main设置width: 100%，占满窗口，从而自适应。
2.为了形成在一行三栏布局，给三个方块都加上浮动float: left;（注意清除浮动，因为浮动会导致父元素高度塌陷）
3.利用负margin-left把三个方块拉到一行，margin-left负多少就是往左移动多少，左边需要相对父元素的-100%，移到父元素的最左边，右边只需要移动本身宽度的负值，即可在最右边。
 区别：
1.双飞翼布局给主面板添加了一个父标签用来通过margin给子面板腾出空间。
2.圣杯采用的是padding，而双飞翼采用的margin，解决了圣杯布局的问题。
3.双飞翼布局不用设置相对布局，以及对应的left和right值。
```

**flex布局**

```
思路：顺着主轴依次放3列，内容在最前，通过order控制显示顺序，通过flex-grow让中间占据全部剩余空间，通过flex-basis设置左、右div的宽度。
缺点：兼容性。
```

#### 13.静态布局、自适应布局、流式布局、响应式布局、弹性布局（rem、em）

##### 静态布局（Static Layout）

```
 即传统Web设计，对于PC设计一个Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分；
 对于移动设备，单独设计一个布局，使用不同的域名如wap.或m.。
```

自适应布局（Adaptive Layout）

```
自适应布局（Adaptive）的特点是分别为不同的屏幕分辨率定义布局。布局切换时页面元素发生改变，但在每个布局中，页面元素不随窗口大小的调整发生变化。
你可以把自适应布局看作是静态布局的一个系列。
```

流式布局（Liquid Layout）

```
流式布局（Liquid）的特点（也叫"Fluid") 是页面元素的宽度按照屏幕进行适配调整，主要的问题是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。
```

响应式布局（Responsive Layout）

```
分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。
可以把响应式布局看作是流式布局和自适应布局设计理念的融合
```

弹性布局（rem/em布局）

```
包裹文字的各元素的尺寸采用em/rem做单位，可以使包裹文字的元素随着文字的缩放而缩放；而页面的主要划分区域的尺寸仍使用百分数或px做单位。
css 中的 px 是css设置自己大小，元素长宽的单位
浏览器中em和px关系是 **16px** = **1em** 
rem是根据根节点，也就是html默认字体大小来设置大小的。所以改变了html根节点字体大小，em的默认值也会改变。向上面html设置为12px，那么**1rem=12px**了
rem不是子节点继承父节点大小，而是所有的节点都继承html节点，所有当html节点设置成10px时候，所有整个页面1rem就等于10px了
```

1.**静态布局：**

 **布局特点：**宽高固定

2.**自适应布局**：

 **布局特点：**不同分辨率下，页面元素位置变化，大小不变

 **实现方法:**针对不同分辨率创建对应的样式表，使用 @media 媒体查询给不同尺寸的设备切换不同的样式

 **缺点：**IE8及以下不支持媒体查询；只能兼容主流分辨率

 3.**流式布局（百分比布局）**:

**布局特点：**不同的分辨率下显示相同的排版；高度固定，宽度自适应

 **实现方法:**网页中主要区域的尺寸使用百分比；

 **缺点：**大屏幕上元素被拉长，但是文字，高度还是固定大小，不协调

 经典流式布局：左侧固定，右侧自适应；两侧固定，中间自适应

4.**弹性布局（rem/em布局）**：

 **布局特点：**页面元素宽度，高度，字体大小会跟着屏幕大小缩放

 **实现方法:**使用js监听当前屏幕大小，设置html的字体大小

 **缺点：**IE678不兼容；需要计算；

5.**响应式布局**：一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本

**布局特点：**每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变，响应式设计的目标是确保一个页面在所有终端上（各种尺寸的PC、手机、手表等等）都能显示出令人满意的效果

 **实现方法：**媒体查询(css3中的Media Query)+流式布局

  媒介查询：通过不同的媒介类型和条件定义样式表规则，媒介查询让CSS可以更精确作用于不同的媒介类型和同一媒介的不同条件。

 **优点：**适应pc和移动端 

 1.面对不同分辨率设备灵活性强

  2.能够快捷解决多设备显示适应问题

 **缺点：**要匹配足够多的屏幕大小，工作量大，设计也需要多个版本

 1.会出现隐藏无用的元素

  2.加载时间加长

#### 14.**less、sass、 stylus分别都有哪些优缺点？**



#### 15.**说一下在IE（IE6）中常见的几个兼容性问题**

一、头文档所引起的怪异盒模型问题

产生条件：不设置文档声明，页面就会陷入怪异盒模型解析模式

解决方法：加入文档声明<!DOCTYPE html>

二、IE6下双边距BUG

产生条件：在IE6下，块元素有浮动有横向的margin，横向的margin值
会被放大成两倍浮动方向与margin方向一致时，该方向会出现双倍边距

解决方法：display:inline

三、图片间隙问题

产生条件：给父容器设置宽度后，图片会在原来基础上把父元素撑大3-5px

解决方法：1.给父元素添加font-size：0；
2.给图片添加display：block；

四、li的间距问题

产生条件：IE6浏览器 li标签设置宽高，且li里面的元素发生了浮动
解决方法：1. li不设置宽高； 

```
               2. li内部的标签不进行浮动
```

五、块状元素默认高度问题

产生条件：部分块状元素会有默认高度（一般为16px-18px之间）
解决方法： 1.给元素添加overflow:hidden;
					2.font-size：0；

六、表单行高不一致

产生条件：一行中的文本输入框和按钮不在同一高度
解决办法：给表单元素添加float：left；并去掉默认边框border：0；

七、图片元素img下高度超出,出现多余空白  

解决方法：1.设置img为display:block;
					2.父级设置overflow:hidden;

八、左浮元素margin-bottom失效

解决方法：1.显示设置高度 
					2.父标签设置_padding-bottom代替子标签的margin-bottom 
					3.再放个标签让父标签浮动，子标签margin- bottom，即(margin-bottom与float不同时						作用于一个标签)

九、position下的left，bottom错位

解决方法：为父级(relative层)设置宽高或添加*zoom:1

十、子级中有设置position，则父级overflow失效

解决方法：为父级设置position:relative

十一、块元素中有文字及右浮动的行元素，行元素换行

解决方法：将行元素置于块元素内的文字前

十二、透明rgba与opacity

产生条件：IE6不支持此两种透明的设置方法
 解决方法：使用IE6当中的滤镜filter替代掉，
如：opacity:0.6;filter:alpha(opacity=60)异盒模型问题



#### 16.清空数组的方法

1.splice

```js
var ary = [1,2,3,4];
ary.splice(0,ary.length);
console.log(ary); // 输出 []，空数组，即被清空了
```

2.**length赋值为0**

```js
var ary = [1,2,3,4];
ary.length = 0;
console.log(ary); // 输出 []，空数组，即被清空了
```

3.**赋值为[]**

```js
var ary = [1,2,3,4];
ary = []; // 赋值为一个空数组以达到清空原数组
```



# 4.js面试题

##### 1.你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?

```
IE: trident内核
Firefox：gecko内核
Safari:webkit内核
Opera:以前是presto内核，Opera现已改用Google Chrome的Blink内核
Chrome:基于webkit
只要能分清浏览器使用什么内核就得满分（safari和chrome使用webkit内核，Firefox使用gecko内核）
```

##### 2.你简述盒模型

```
box-sizing:content-box（W3C盒模型，又名标准盒模型）：元素的宽高大小表现为内容的大小。 
box-sizing:border-box（IE盒模型，又名怪异盒模型）：元素的宽高表现为内容 + 内边距 + 边框的大小。背景会延伸到边框的外沿。
```

##### 3.CSS3的新特性

```
word-wrap 文字换行
text-overflow 超过指定容器的边界时如何显示
text-decoration 文字渲染
text-shadow文字阴影
gradient渐变效果
transition过渡效果 transition-duration：过渡的持续时间
transform拉伸，压缩，旋转，偏移等变换
animation动画
transition和animation的区别： 

Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，  。
```

##### 4.CSS选择器及其优先级

```
!important
内联样式style=""
ID选择器#id
类选择器/属性选择器/伪类选择器.class.active[href=""]
元素选择器/关系选择器/伪元素选择器html+div>span::after
通配符选择器*
```

##### 5.说说BFC

```
BFC（Block Formatting Context）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。 
BFC应用
防止margin重叠
清除内部浮动
自适应两（多）栏布局
防止字体环绕

触发BFC条件
根元素
float的值不为none
overflow的值不为visible
display的值为inline-block、table-cell、table-caption
position的值为absolute、fixed

BFC的特性
内部的Box会在垂直方向上一个接一个的放置。
垂直方向上的距离由margin决定
bfc的区域不会与float的元素区域重叠。
计算bfc的高度时，浮动元素也参与计算
bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。
```

##### 6.说说定位相关的属性

```
position 属性的五个值：
| **值**   | **描述**                                                     |
| -------- | ------------------------------------------------------------ |
| static   | 默认。位置设置为 static 的元素，   它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。HTML 元素的默认值，即没有定位，遵循正常的文档流对象。从上到下,从左到右   静态定位的元素不会受到 top, bottom, left, right影响。 |
| absolute | 位置设置为 absolute 的元素，可定位于相对于第一个已定位（非静态的）的包含它的元素的指定坐标。   绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>   此元素的位置可通过 "left"、"top"、"right" 以及 "bottom" 属性来规定。   absolute 定位使元素的位置与文档流无关，因此不占据空间。   absolute 定位的元素和其他元素重叠。   会将原来的块元素变成行内块元素 |
| fixed    | 位置被设置为 fixed 的元素，可定位于相对于浏览器窗口的指定坐标。元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动   此元素的位置可通过 "left"、"top"、"right" 以及 "bottom" 属性来规定。   不论窗口滚动与否，元素都会留在那个位置。工作于 IE7（strict 模式）。   会将原来的块元素变成行内块元素 |
| relative | 位置被设置为 relative 的元素，可将其定位于相对于其正常位置的地方，   因此 "left:20" 会将元素移至元素正常位置左边 20 个像素的位置。   相对定位元素的定位是相对其自身正常位置。   移动相对定位元素，但它原本所占的空间不会改变。 |
| sticky   | sticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。   position:   sticky; 基于用户的滚动位置来定位。   粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。   它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。   元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。   这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top,   right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。 |
| inherit  | position 属性的值从父元素继承。                              |
```

##### 7.谈谈flex布局

```
采用 Flex 布局的元素，称为 Flex容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex项目（flex item），简称“项目”。
1.父元素属性
| **属性名**      | **属性值**      | **备注** 
| display        | flex          | 定义了一个flex容器，它的直接子元素会接受这个flex环境         |
| flex-direction | row,   row-reverse,   column,   column-reverse  | 决定主轴的方向         
| flex-wrap       | nowrap,   wrap,   wrap-reverse   | 如果一条轴线排不下，如何换行           
| flex-flow       | [flex-direction] , [flex-wrap] | 是 flex-direction属性和    flex-wrap属性的简写形式，   默认值为 row nowrap |
| justify-content | flex-start,   flex-end,   center,   space-between,   space-around | 设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式         |
| align-items     | flex-start,   flex-end,   center,   baseline,   stretch      | 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式         |                                 |
2.子元素属性      |                                                              |         
| 属性名          | 属性值           | 备注     
| order           | [int]    | 默认情况下flex order会按照书写顺训呈现，   可以通过order属性改变，   数值小的在前面，还可以是负数。 |
| flex-grow       | [number]  | 设置或检索弹性盒的扩展比率,   根据弹性盒子元素所设置的扩展因子作为比率来分配剩余空间 |
| flex-shrink     | [number]  | 设置或检索弹性盒的收缩比率,   根据弹性盒子元素所设置的收缩因子作为比率来收缩空间 |
| flex-basis      | [length], auto  | 设置或检索弹性盒伸缩基准值                               
| align-self      | auto,flex-start,flex-end,center,baseline,stretch   | 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式，   可以覆盖父容器align-items的设置 |
```

##### 8.你怎么清楚浮动

```
1、在浮动元素后面添加 clear:both 的空 div 元素
<div class="container">
<div class="left"></div>
<div class="right"></div>
<div style="clear:both"></div>
</div>
2、给父元素添加 overflow:hidden 或者 auto 样式，触发BFC。
<div class="container">
<div class="left"></div>
<div class="right"></div>
</div>
.container{
​    width: 300px;
​    background-color: #aaa;
​    overflow:hidden;
​    zoom:1;   /*IE6*/
}
3、使用伪元素，也是在元素末尾添加一个点并带有 clear: both 属性的元素实现的。
<div class="container  clearfix">
<div class="left"></div>
<div class="right"></div>
</div>
.clearfix{
​    zoom: 1; /*IE6*/
}
.clearfix:after{
​    content: ".";
​    height: 0;
​    clear: both;
​    display: block;
​    visibility: hidden;
}
推荐使用第三种方法，不会在页面新增div，文档结构更加清晰。
```

##### 9.两边宽度固定中间自适应的三栏布局(默写题,手写笔试题)

圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局。
圣杯布局
双飞翼布局

##### 10.浏览器渲染机制

```
构建DOM树（parse）：渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node
构建渲染树（construct）：解析对应的CSS样式文件信息
布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；
绘制渲染树（paint/repaint）：遍历渲染树，使用UI后端层来绘制每个节点
```

##### 11.重绘和回流的区别

```
重绘（repaint或redraw）：当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。
重绘发生在元素的可见的外观被改变，但并没有影响到布局的时候。比如，仅修改DOM元素的字体颜色（只有Repaint，因为不需要调整布局）

回流（重构/重排/reflow）：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。
触发回流的条件：任何页面布局和几何属性的改变都会触发回流：
页面渲染初始化(无法避免)
添加或删除可见的DOM元素
元素位置的改变，或者使用动画
元素尺寸的改变——大小，外边距，边框
浏览器窗口尺寸的变化
填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变

回流必定会引发重绘，但重绘不一定会引发回流。
```

##### 12.JS数据类型

```
1基本数据类型:string,number,Boolean,null,undefined;
2引用数据类型object(Object,Array),function
3 ES6新增 symbol
```

##### 13.JS判断数据类型的方法

```
typeof
console.log(typeof 2);               // number
console.log(typeof true);            // boolean
console.log(typeof 'str');           // string
console.log(typeof undefined);       // undefined
console.log(typeof []);              // object 
console.log(typeof {});              // object
console.log(typeof function(){});    // function
console.log(typeof null);            // object
优点：能够快速区分基本数据类型 
缺点：不能将Object、Array和Null区分，都返回object

instanceof
console.log(2 instanceof Number);                    // false
console.log(true instanceof Boolean);                // false 
console.log('str' instanceof String);                // false  
console.log([] instanceof Array);                    // true
console.log(function(){} instanceof Function);       // true
console.log({} instanceof Object);                   // true
优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象 
缺点：Number，Boolean，String基本数据类型不能判断
 
Object.prototype.toString.call()
console.log(toString.call(2));                      //[object Number]
console.log(toString.call(true));                   //[object Boolean]
console.log(toString.call('str'));                  //[object String]
console.log(toString.call([]));                     //[object Array]
console.log(toString.call(function(){}));           //[object Function]
console.log(toString.call({}));                     //[object Object]
console.log(toString.call(undefined));              //[object Undefined]
console.log(toString.call(null));                   //[object Null]
优点：精准判断数据类型 
缺点：写法繁琐不容易记，推荐进行封装后使用
```

##### 14.null和undefined区别

```
Undefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。用法：
变量被声明了，但没有赋值时，就等于undefined。
调用函数时，应该提供的参数没有提供，该参数等于undefined。
对象没有赋值的属性，该属性的值为undefined。
函数没有返回值时，默认返回undefined。
Null类型也只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。用法
作为函数的参数，表示该函数的参数不是对象。
作为对象原型链的终点。
```

##### 15.JS作用域的理解

```
JS中的作用域分为两种：全局作用域和函数作用域。函数作用域中定义的变量，只能在函数中调用，外界无法访问。没有块级作用域导致了if或for这样的逻辑语句中定义的变量可以被外界访问，因此ES6中新增了let和const命令来进行块级作用域的声明。
```

##### 16.call,apply和bind区别的页面在哪些流览器测

```
三个函数的作用都是将函数绑定到上下文中，用来改变函数中this的指向；三者的不同点在于语法的不同。
fun.call(thisArg[, arg1[, arg2[, ...]]])
fun.apply(thisArg, [argsArray])
所以 apply和 call的区别是 call方法接受的是若干个参数列表，而 apply接收的是一个包含多个参数的数组。
而bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。
var bindFn = fun.bind(thisArg[, arg1[, arg2[, ...]]])
bindFn()
```

##### 17.深拷贝和浅拷贝

```
深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。
浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。
深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。
```

##### 18.谈谈防抖和节流

```
说白了，防抖节流就是使用定时器来实现我们的目的。
防抖(debounce)：
在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。
典型的案例就是输入框搜索：输入结束后n秒才进行搜索请求，n秒内又输入的内容，则重新计时。
节流(throttle)：
规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效。
典型的案例就是鼠标不断点击触发，规定在n秒内多次点击只生效一次。
为什么要掌握防抖和节流
函数节流（throttle）与函数防抖（debounce）都是可以限制函数的执行频次，根据不同的场景来对执行频率进行限制，避免了函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。
```

##### 19.谈谈cookie,sessionStorage和localStorage

```
cookie用来保存登录信息，大小限制为4KB左右
localStorage是Html5新增的，用于本地数据存储，保存的数据没有过期时间，一般浏览器大小限制在5MB
sessionStorage接口方法和localStorage类似，但保存的数据的只会在当前会话中保存下来，页面关闭后会被清空。
| **名称**       | **生命期**       | **大小** | **与服务器通信**                             
| cookie       | 一般由服务器生成，可设置失效时间。   如果在浏览器端生成Cookie，   默认是关闭浏览器后失效 | 4KB      | 每次都会携带在HTTP头中，   如果使用cookie保存过多数据会带来性能问题 |
| localStorage   | 除非被清除，   否则永久保存                                  | 5MB      | 仅在浏览器中保存，不与服务器通信                             |
| sessionStorage | 仅在当前会话下有效，   关闭页面或浏览器后被清除              | 5MB      | 仅在浏览器中保存，不与服务器通信                             |
```

##### 20.0.1+0.2!=0.3怎么处理

```
在计算机中数字无论是定点数还是浮点数都是以多位二进制的方式进行存储的,计算机天生只能存储整数，它只能用某种方法来表示小数
解决方法：
1.把计算数字 提升 10 的N次方 倍 再 除以 10的N次方。N>1.
(0.1*10+ 0.2*10)/10== 0.3//true
2.四舍五入  Match.
```

##### 21.数组的常用方法(至少说出8个)

```
1.shift 删除数组中的第一个元素
2.pop 删除数组中的最后一个元素
3.unshift 增加元素在数组的前面
4.push 增加元素在数组的后面
5.map 循环，并且返回新的数组
6.forEach 循环，遍历
7.filter 过滤，筛选出数组中的满足条件的，并且返回新的数组
8.concnt 合并数组
9.find 查找出第一个符合条件中的数组元素
10.findIndex 查找出第一个符合条件中的数组元素，所在的索引位置
11.flat 将多维数组转为一维数组
12.join将数组转为字符串
13.reverse 颠倒数组中的顺序
14.every检测数组中元素是否都是符合条件 === bollean
15.some检测数组中元素是否有满足条件的元素 === bollean
16.splice(start,n,添加元素) 开始位置 删除个数，添加元素
17.sort 排序
18.slice(start,end) 选中[start.end)之间的元素
19.indexOf 查找值所在的位置
20.includes 查看数组中是否存在此元素
```

##### 22.new一个对象的过程中发生了什么吗?

```
\1. 创建空对象；
var obj = {};
\2. 设置新对象的constructor属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的prototype对象；
obj.__proto__ = ClassA.prototype;
\3. 使用新对象调用函数，函数中的this被指向新实例对象：
ClassA.call(obj);//{}.构造函数();
\4. 将初始化完毕的新对象地址，保存到等号左边的变量中
```

23.JS实现继承(至少会一种)

```
1. 原型链
2. 借用构造函数
3. 组合继承
4. 寄生式继承
6. 原型式继承　　
```

##### 24.get和post区别

| **请求方式**   | **GET**                            | **POST**                   |
| -------------- | ---------------------------------- | -------------------------- |
| 参数位置       | 参数拼接到url的后面                | 参数在请求体中             |
| 参数大小       | 受限于浏览器url大小，一般不超过32K | 1G                         |
| 服务器数据接收 | 接收1次                            | 根据数据大小，可分多次接收 |
| 适用场景       | 从服务器端获取数据                 | 向服务器提交数据           |
| 安全性         | 参数携带在url中，安全性低          | 相对于GET请求，安全性更高  |

##### 25.JSONP原理

```
由于浏览器的同源策略限制，不允许跨域请求；但是页面中的 script、img、iframe标签是例外，不受同源策略限制。
Jsonp 就是利用 script标签跨域特性进行请求。
JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好一个同名回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数。
JSONP缺点：它只支持 GET请求，而不支持 POST请求等其他类型的HTTP请求。
```

##### 26.缓存的理解

```
缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
强缓存:
Expires
cache-control
协商缓存:
Last-Modified 和 If-Modified-Since
Etag 和 If-None-Match
```

##### 27.XSS和CSRF区别

```
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表 CSS 混淆，故将跨站脚本攻击缩写为 XSS。恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注入JS代码，然后执行JS里的代码。
CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
CSRF的目标是用户，XSS的目标是服务器
XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```

##### 28.HTTP与HTTPS的区别

```
HTTP的URL由 http://起始且默认使用端口80，而HTTPS的URL由 https://起始且默认使用端口443
HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的 SSL 加密传输协议
HTTP的连接很简单，是无状态的，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全
```

##### 29.HTTP状态码

```
1XX 信息性状态码
2XX 成功状态码
3XX 重定向状态码
4XX客户端错误状态码
5XX服务器错误状态码
我们常见的状态码有200--表示客户端请求成功，400--表示客户端请求有语法错误，403--表示服务器收到请求，但是没有权限，404--表示请求资源不存在，500--表示服务器端错误
```

##### 30.事件捕获、事件冒泡、阻止事件冒泡、阻止默认事件

```
事件捕获
捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)
事件冒泡
冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。
阻止事件的传播,阻止事件冒泡：
• 在W3c中，使用stopPropagation（）方法
• 在IE下设置cancelBubble = true；
阻止事件的默认行为，例如click <a>后的跳转~
• 在W3c中，使用preventDefault（）方法；
• 在IE下设置window.event.returnValue = false;
```

##### 31.Js事件循环机制

```
在线程之内，又被分为了两个队列：同步任务队列,异步任务队列
同步环境执行(step1) -> 事件循环1(step4) -> 事件循环2(step4的重复)…
　　其中的异步进程有：
　　　　a、类似onclick等，由浏览器内核的DOM binding模块处理，事件触发时，回调函数添加到任务队列中；
　　　　b、setTimeout等，由浏览器内核的Timer模块处理，时间到达时，回调函数添加到任务队列中；
　　　　c、Ajax，由浏览器内核的Network模块处理，网络请求返回后，添加到任务队列中。
异步执行的运行机制
（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
（4）主线程不断重复上面的第三步。
```

##### 32.面向对象、原型、原型链、继承

```

```



##### 33.什么是闭包，使用场景及优缺点？

```
闭包的概念
   当一个函数内部嵌套另一个函数，子函数可以访问到父级函数中的变量，就是闭包。严格来说，闭包产生的三个条件
  1.必须是嵌套关系 2.内部函数访问其所在的作用域 3.在所在作用域外被调用**
**闭包的作用与应用场景**
作用一 使变量在内存中保存不被销毁。
作用二，延长了函数内局部变量的作用范围。
```

##### 34.this指向

```
普通函数调用，此时 this 指向 window
构造函数调用， 此时 this 指向 实例对象
对象方法调用， 此时 this 指向 该方法所属的对象
通过事件绑定的方法， 此时 this 指向 绑定事件的对象
定时器函数， 此时 this 指向 window
箭头函数中的this指向，箭头函数中没有自己的this，它的this是继承而来，默认指向在定义它时所处的对象(宿主对象)。
当函数被当作监听事件处理函数时，其this指向触发该事件的元素（针对于addEventListener 事件）
更改this指向的三个方法
call() 方法 （.call(obj,2,3)）
apply() 方法（.apply(obj.[2,3])）
call接受的参数为一个一个的，但是apply接受的参数只能为一个严格的数组
bind()方法 (.bind(obj))
```

##### 35.箭头函数和普通函数的区别？  

```
（1）箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
（2）箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
（3）箭头函数不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
（4）箭头函数不可以使用yield命令，因此箭头函数不能用作 Generator 函数
（5）箭头函数使用call()和apply()调用
```

36. ##### 什么是promise? 

```
简单来说可以把promise当作一个装着异步操作结果的容器。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。它将异步函数以同步的方式书写，也解决了回调地狱问题
特点：（1）对象状态不受外界影响  
     （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果
缺点：（1），无法取消promise，一旦新建它就会立即执行，无法中途取消  
     （2），如果不设置回调函数，promise内部抛出的错误，不会反应到外部 
     （3）无法得知目前进展到哪一个阶段（刚刚开始还是即将结束）
三个状态：进行中、已成功、以失败。 
```

##### 37.什么是ajax？

```
 即异步的 JavaScript 和 XML，是一种用于创建快速动态网页的技术；传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。使用AJAX则不需要加载更新整个网页，实现部分内容更新。
```

# 5.兼容性面试题

#### 1、IE8 下面的 png 图片无法正常显示？

原因：打开调试面板，你会发现 IE8 浏览器把 PNG 格式的 img 解析成了 span 标签，导致图无法显
示。
解决方案：在样式里面对 span 设置宽高和 display:inline-block;即可。

#### 2、rgba 不支持 IE8？

解决方案:可以用 opacity
opacity:0.7;/**FF chrome safari opera**/
filter:alpha(opacity:70);/*用了 ie 滤镜,可以兼容 ie*/
但是,需要注意的是,opacity 会影响里面元素的透明度

#### 3、Css3 的新属性？

当一些 CSS3 样式语法还存在波动时，它们提供针对浏览器的前缀。现在主要流行的浏览器内核主
要有：
Trident 内核：主要代表为 IE 浏览器
Gecko 内核：主要代表为 Firefox   FF
Presto 内核：主要代表为 Opera
Webkit 内核：产要代表为 Chrome 和 Safari
而这些不同内核的浏览器，CSS3 属性（部分需要添加前缀的属性）对应需要添加不同的前缀，也将
其称之为浏览器的私有前缀，添加上私有前缀之后的 CSS3 属性可以说是对应浏览器的私有属性：
Trident 内核：前缀为-ms
Gecko 内核：前缀为-moz
Presto 内核：前缀为-o
Webkit 内核：前缀为-webkit

#### 4、document.form.item 问题

问题：代码中存在 document.formName.item("itemName") 这样的语句，不能在 FF 下运行
解决方法：改用 document.formName.elements["elementName"]

#### 5、集合类对象问题

问题：代码中许多集合类对象取用时使用()，IE 能接受，FF 不能
解决方法：
改用 [] 作为下标运算，例：
document.getElementsByName("inputName")(1)  改 为
document.getElementsByName("inputName")[1]

#### 6、window.event || event

问题：使用 window.event 无法在 FF 上运行
解决方法：
FF 的 event 只能在事件发生的现场使用，此问题暂无法解决。可以把 event 传到函数里变通
解决：
onMouseMove = "functionName(event)"
function functionName (e) {
e = e || window.event;
......
}

#### 7、HTML 对象的 id 作为对象名的问题

问题：在 IE 中，HTML 对象的 ID 可以作为 document 的下属对象变量名直接使用，在 FF 中不能
解决方法：
使用对象变量时全部用标准的 getElementById("idName")  通过id取dom节点

#### 8、用 idName 字符串取得对象的问题

问题：在 IE 中，利用 eval_r("idName") 可以取得 id 为 idName 的 HTML 对象，在 FF 中不能
解决方法：
用 getElementById("idName") 代替 eval_r("idName")

#### 9、变量名与某 HTML 对象 id 相同的问题

问题：在 FF 中，因为对象 id 不作为 HTML 对象的名称，所以可以使用与 HTML 对象 id 相同的变量
名，IE 中不能
解决方法：
在声明变量时，一律加上 var ，以避免歧义，这样在 IE 中亦可正常运行
最好不要取与 HTML 对象 id 相同的变量名，以减少错误    

#### 10、event.x 与 event.y 问题

问题：在 IE 中，event 对象有 x,y 属性，FF 中没有
解决方法：
在 FF 中，与 event.x 等效的是 event.pageX ，但 event.pageX IE 中没有
故采用 event.clientX 代替 event.x ，在 IE 中也有这个变量
event.clientX 与 event.pageX 有微妙的差别，就是滚动条
要完全一样，可以这样：
mX = event.x ? event.x : event.pageX;
然后用 mX 代替 event.x

#### 11、 取得元素的属性

在 FF 中，自己定义的属性必须 getAttribute() 取得  

在 FF 中没有 parentElement，parement.children 而用 parentNode，parentNode.childNodes

问题：
childNodes 的下标的含义在 IE 和 FF 中不同，FF 的 childNodes 中会插入空白文本节点
解决方法：
可以通过 node.getElementsByTagName_r() 来回避这个问题
问题：当 html 中节点缺失时，IE 和 FF 对 parentNode 的解释不同，例如：
​      FF 中 input.parentNode 的值为 form，而 IE 中 input.parentNode    的值为空节点
​问题：FF 中节点自己没有 removeNode 方法
解决方法：
   必须使用如下方法 node.parentNode.removeChild(node)

#### 12、const 问题

问题：在 IE 中不能使用 const 关键字
解决方法：以 var 代替

#### 13、body 对象

FF 的 body 在 body 标签没有被浏览器完全读入之前就存在，而 IE 则必须在 body 完全被读
入之后才存在
这会产生在 IE 下，文档没有载入完时，在 body 上 appendChild 会出现空白页面的问题
解决方法：
一切在 body 上插入节点的动作，全部在 onload 后进行

#### 14、url encoding

问题：
一般 FF 无法识别 js 中的&

解决方法：
在 js 中如果书写 url 就直接写&不要写&

#### 15、nodeName 和 tagName 问题

问题：
在 FF 中，所有节点均有 nodeName 值，但 textNode 没有 tagName 值，在 IE 中，nodeName
的使用有问题
解决方法：
使用 tagName，但应检测其是否为空



#### 16.元素属性

IE下input.type 属性为只读，但是FF下可以修改

 document.getElementsByName() 和document.all[name] 的问题

问题：在IE中，getElementsByName()、document.all[name] 均不能用来取得div 元素是否还有其它不能取的元素还不知道（这个问题还有争议，还在研究中）

#### 17.调用子框架或者其它框架中的元素的问题

在IE中，可以用如下方法来取得子元素中的值

document.getElementByIdx_x("frameName").(document.)elementName

window.frames["frameName"].elementName

在FF中则需要改成如下形式来执行，与IE兼容：window.frames["frameName"].contentWindow.document.elementName

window.frames["frameName"].document.elementName

#### 18.对象宽高赋值问题

问题：FireFox中类似obj.style.height = imgObj.height 的语句无效

解决方法：统一使用obj.style.height = imgObj.height + "px";

#### 19.innerText的问题

问题：innerText 在IE中能正常工作，但是innerText 在FireFox中却不行

解决方法：在非IE浏览器中使用textContent代替innerText

#### 20.event.srcElement和event.toElement问题

问题：IE下，even对象有srcElement属性，但是没有target属性；Firefox下，even对象有target属性，但是没有srcElement属性

解决方法：var source = e.target || e.srcElement;var target = e.relatedTarget || e.toElement;

#### 21.禁止选取网页内容

问题：FF需要用CSS禁止，IE用JS禁止

解决方法：IE: obj.onselectstart = function() {return false;}

​					FF: -moz-user-select:none;

#### 22.捕获事件

问题：火狐(FF)没有setCapture(),releaseCapture()方法

解决方法：
      IE：obj.setCapture();
             obj.releaseCapture()
      FF：
             window.captureEvents(Event.MouseMove|Event.MoouseUp);
             window.releaseEvents(Event.MouseMove|Event.MouseUp)

#### 移动端常见的兼容性问题

##### 1.html5调用安卓或者ios的拨号功能

html5提供了自动调用拨号的标签，只要在a标签的href中添加tel：就可以了。如下：
< a href=" ">400-810-6999 转 1034</ a>
拨打手机如下：
< a href="tel:15677776767">点击拨打 15677776767 </ a>

##### 2.上下拉动滚动条时卡顿、慢

   body {
		-webkit-overflow-scrolling: touch; 
		overflow-scrolling: touch;
	}
 Android3+和 iOS5+支持 CSS3 的新属性为 overflow-scrolling。

##### 3.圆角bug

某些 Android 手机圆角失效
background-clip: padding-box;

##### 4.ios 设置input 按钮样式会被默认样式覆盖

解决方式如下：

input,textarea {
border: 0;
-webkit-appearance: none;
}
设置默认样式为 none

##### 5.IOS键盘字母输入，默认首字母大写

解决方案，设置如下属性

<input type="text"autocapitalize="off"/>

##### 6.h5底部输入框被键盘遮挡问题

h5页面有个问题是，当输入框在最底部，点击软键盘后输入框会被遮挡。可采用如下方式解决

var oHeight = $(document).height(); //浏览器当前的高度 

​	 $(window).resize(function(){

​			 if($(document).height() < oHeight){ 

​					 $("#footer").css("position","static"); 

​					}else{ 

​							 $("#footer").css("position","absolute");

​				 	} 

​	 });

##### 7.IOS移动端click事件300ms的延迟响应

解决方案：

1、fastclick可以解决在手机上点击事件的300ms延迟

2、zepto的touch模块，tap事件也是为了解决在click的延迟问题

3、触摸事件的响应顺序为touchstart --> touchmove --> touchend --> click,也可以通过绑定ontouchstart事件，加快对事件的响应，解决300ms延迟问题

##### 8.在ios和andriod中,audio元素和video元素在无法自动播放

应对方案：触屏即播$('html').one('touchstart',function(){audio.play()})

##### 9.CSS动画页面闪白,动画卡顿

解决方法:

1.尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位

2.开启硬件加速

 -webkit-transform: translate3d(0, 0, 0);

 -moz-transform: translate3d(0, 0, 0);

 -ms-transform: translate3d(0, 0, 0); 

  transform: translate3d(0, 0, 0);

##### 10.fixed定位缺陷

1、ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位

2、android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位

3、ios4下不支持position:fixed解决方案：可用iScroll插件解决这个问题







# 6.webpack面试题

##### 1、如何减少 Webpack 打包时间

```
1.优化 Loader
2.HappyPack
3.DllPlugin
4.代码压缩
5.一些小的优化点
```



##### 2、如何减少 Webpack 打包后的文件体积

```
1.按需加载，将每个路由页面单独打包为一个文件
2.Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。
3.Tree Shaking 可以实现删除项目中未被引用的代码
```



##### 3、什么是模块化？

```
模块化是指把一个复杂的系统分解到多个模块以方便编码。
```

##### 4、为什么出现模块化？

```
很久以前，开发网页要通过命名空间的方式来组织代码，例如 jQuery 库把它的API都放在了window.$下，在加载完 jQuery 后其他模块再通过window.$去使用 jQuery。 这样做有很多问题，其中包括：

命名空间冲突，两个库可能会使用同一个名称，例如Zepto也被放在window.$下；
无法合理地管理项目的依赖和版本；
无法方便地控制依赖的加载顺序。
当项目变大时这种方式将变得难以维护，需要用模块化的思想来组织代码。
```

##### 5、构建的作用及常见功能是什么？

```
构建就是当源代码无法直接运行时，通过转化将源代码转换成可执行的 JavaScript、Css、HTML代码。
一般包括如下内容：

代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。
文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。
代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。
模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。
自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。
代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。
自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。
```

##### 6、你了解的构建工具有哪些，各自有什么优缺点？

```
1. Webpack
Webpack的优点是：专注于处理模块化的项目，能做到开箱即用一步到位；
    通过 Plugin 扩展，完整好用又不失灵活；
    使用场景不仅限于 Web 开发；
    社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；
    良好的开发体验。
Webpack的缺点是只能用于采用模块化开发的项目。
2.Rollup
Rollup 是在 Webpack 流行后出现的替代品；
Rollup 生态链还不完善，体验不如 Webpack；
Rollup 功能不如 Webpack 完善，但其配置和使用更加简单；
Rollup 不支持 Code Spliting，但好处是打包出来的代码中没有 Webpack 那段模块的加载、执行和缓存的代码。
Rollup 在用于打包 JavaScript 库时比 Webpack 更加有优势，因为其打包出来的代码更小更快。 但功能不够完善，很多场景都找不到现成的解决方案。


```

##### 7、简单介绍一下webpack

```
	Webpack是一个打包模块化 javascript 的工具，它会从 main.js 出发，识别出源码中的模块化导入语句，递归地找出入口文件的所有依赖，将入口和其所有依赖打包到一个单独的文件中。从webpack 2版本开始，webpack已经内置了对ES6、CommonJS、AMD模块化语句的支持
```

##### 8、Loader机制的作用是什么？

```
Loader 可以看作具有文件转换功能的翻译员，配置里的module.rules数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换。
```

##### 9、css-loader与style-loader的作用

```
css-loader读取 CSS 文件
style-loader把 CSS 内容注入到 JavaScript 里

```

##### 10、配置 Loader 时需要注意的地方？

```
1、use属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的；
2、每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如css-loader?minimize中的minimize告诉css-loader要开启 CSS 压缩。

```

##### 11、Plugin（插件）的作用是什么？

```
	Plugin 是用来扩展 Webpack 功能的，通过在构建流程里注入钩子实现，它给 Webpack 带来了很大的灵活性。
Webpack 是通过plugins属性来配置需要使用的插件列表的。plugins属性是一个数组，里面的每一项都是插件的一个实例，在实例化一个组件时可以通过构造函数传入这个组件支持的配置属性。

```

##### 12、ExtractTextPlugin插件的作用

```
	ExtractTextPlugin插件的作用是提取出 JavaScript 代码里的 CSS 到一个单独的文件。
对此你可以通过插件的filename属性，告诉插件输出的 CSS 文件名称是通过[name]_[contenthash:8].css字符串模版生成的，里面的[name]代表文件名称，[contenthash:8]代表根据文件内容算出的8位 hash 值， 还有很多配置选项可以在ExtractTextPlugin的主页上查到。

```

##### 13、DevServer开发工具

```
	DevServer 会启动一个 HTTP 服务器用于服务网页请求，同时会帮助启动 Webpack ，并接收 Webpack 发出的文件更变信号，通过 WebSocket 协议自动刷新网页做到实时预览。

```

##### 14、实时预览

```
	Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。Webpack 默认是关闭监听模式的，你可以在启动 Webpack 时通过webpack --watch来开启监听模式。
通过 DevServer 启动的 Webpack 会开启监听模式，当发生变化时重新执行完构建后通知 DevServer。 DevServer 会让 Webpack 在构建出的 JavaScript 代码里注入一个代理客户端用于控制网页，网页和 DevServer 之间通过 WebSocket 协议通信， 以方便 DevServer 主动向客户端发送命令。 DevServer 在收到来自** Webpack 的文件变化**通知时通过 注入的客户端控制网页刷新。

```

##### 15、什么是模块热替换？

```
	模块热替换能做到在不重新加载整个网页的情况下，通过将被更新过的模块替换老的模块，再重新执行一次来实现实时预览。
模块热替换相对于默认的刷新机制能提供更快的响应和更好的开发体验。 模块热替换默认是关闭的，要开启模块热替换，你只需在启动 DevServer 时带上--hot参数，重启 DevServer 后再去更新文件就能体验到模块热替换的神奇了。

```

##### 16、什么是Source Map 及其使用

```
	Source Map能够提供将压缩文件恢复到源文件原始位置的映射代码的方式。这意味着你可以在优化压缩代码后轻松的进行调试。在编译器输出的代码上进行断点调试是一件辛苦和不优雅的事情， 调试工具可以通过Source Map映射代码，让你在源代码上断点调试。

Source Map使用：Webpack 支持生成 Source Map，只需在启动时带上--devtool source-map参数。 加上参数重启 DevServer 后刷新页面，再打开 Chrome 浏览器的开发者工具，就可在 Sources 栏中看到可调试的源代码了。

```

##### 17、Webpack的几个核心概念

```
Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。
Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。
Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。
Loader：模块转换器，用于把模块原内容按照需求转换成新内容。
Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。
Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。

```

##### 18、Webpack简单工作原理

```
	Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。

```

##### 19.什么是loader ? 什么是Plugin ? loader和plugin有什么区别？

```
webapck默认只能打包JS和JOSN模块，要打包其它模块，需要借助loader，loader就可以让模块中的内容转化成webpack或其它laoder可以识别的内容。

loader就是模块转换化，或叫加载器。不同的文件，需要不同的loader来处理。
plugin是插件，可以参与到整个webpack打包的流程中，不同的插件，在合适的时机，可以做不同的事件。

**css-loader:**
加载css模块 转换成模块化的css 让webpack识别它
**style-loader:**
把css代码注入到js中，通过DOM操作去加载CSS 把css代码放到了header标签中style标签中
**babel-loader** 
把JS高阶转成JS低阶 pollyfill
**eslint-loader:**
检查JS代码是否符合某个规则
**file-loader:**
把文件输出到一个文件夹中，在代码中通过URL引用输出的文件
**url-loader:**
和file-loader类似，比file-loader强大一个，让小图片直接生成base64
**less-loader:**
把less代码转化css代码
**html-loader:**
处理html模块中的插件图片等

```

##### 20.webpack中都有哪些插件，这些插件有什么作用？

```
html-webpack-plugin**
自动创建一个HTML文件，并把打包好的JS插入到HTML文件中
**clean-webpack-plugin**
在每一次打包之前，删除整个输出文件夹下所有的内容
**mini-css-extrcat-plugin**
抽离CSS代码，放到一个单独的文件中
**optimize-css-assets-plugin**
压缩css

```

##### 21.如何利用webpack优化前端性能? 

```
1. 压缩代码**。删除多余的代码、注释、简化代码的写法等等方式
2. 利用 **CDN** 加速。在构建过程中，将引用的静态资源路径修改为 CDN 上对应的路径
3. **删除死代码**，将代码中永远不会走到的片段删除掉
4. **优化图片**，对于小图可以使用 base64 的方式写入文件中
5. 按照路由拆分代码，实现按需加载，**提取公共代码**
6. 给打包出来的文件名添加哈希，实现浏览器缓存文件，版本

```



# 7.vue3.0面试题

##### 1.Vue3.0和Vue2.0的区别

```
· 3.0比2.0 快2倍
· 3.0去掉了filter, 么有beforeCreate created,用setup取代
· reactivity是可以单独作为库使用的 
· 单独功能可以抽离 取代了mixin  优于mixin 解决上下反复横跳
· 支持多个子节点 fragment
· setup里没有this
· Proxy实现响应式不需要set delete  兼容性并不好
· 响应式方面 性能得到很大提升 不用初始化的时候就递归遍历属性
· 响应式不区分数组和对象
· 3.0兼容IE12以上
· composition api 可以和 options API 同时存在

```

##### 2.Vue3.0都有哪些重要新特性？

```
建议往`Composition API`和`Tree-shaking`方面答，对应比较`React Hooks`和webpack 的`Tree-shaking`
composition-api解决了什么问题
1.使用传统的option配置方法写组件的时候问题，随着业务复杂度越来越高，代码量会不断的加大；由于相关业务的代码需要遵循option的配置写到特定的区域，导致后续维护非常的复杂，同时代码可复用性不高，而composition-api就是为了解决这个问题而生的
compositon-api提供了一下几个函数
reactive
watchEffect
computed
ref
toRefs
生命周期的hooks
2.Vue3提出万物皆可 TreeShaking的概念
什么是 TreeShaking 
TreeShaking 是一个术语，指的是在打包构建过程中移除没有被引用到的代码，这些代码可以成为 dead code。这个概念最早在基于 ES6 的打包工具 Rollup 中提出，后来被引入到 webpack 中。TreeShaking 比较依赖于 ES6 模块系统的静态结构特性，比如 import 和 export。
```

##### 3.Vue3.0` 对比`Vue2.0的优势在哪？

```
vue3.0 的发布与 vue2.0 相比，优势主要体现在：更快、更小、更易维护、更易于原生、让开发者更轻松；
更快
　　1、virtual DOM 完全重写，mounting & patching 提速 100%；
　　2、更多编译时 （compile-time）提醒以减少 runtime 开销；
　　3、基于 Proxy 观察者机制以满足全语言覆盖以及更好的性能；
　　4、放弃 Object.defineProperty ，使用更快的原生 Proxy；
　　5、组件实例初始化速度提高 100%;
　　6、提速一倍/内存使用降低一半；
更小
　　1、Tree-shaking 更友好；
　　2、新的 core runtime：~ 10kb gzipped
```

##### 4.Vue3.0`和`React 16.X都有哪些区别和相似处？

```
相似之处
他们都是JavaScript的UI框架，专注于创造前端的富应用
不同于早期的JavaScript框架“功能齐全”，Reat与Vue只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件。
Vue.js(2.0版本)与React的其中最大一个相似之处，就是他们都使用了一种叫’Virtual DOM’的东西
都鼓励组件化
看到React和Vue都有’props’的概念，这是properties的简写。props在组件中是一个特殊的属性，允许父组件往子组件传送数据。
React和Vue都有自己的构建工具，你可以使用它快速搭建开发环境
React和Vue都有很好的Chrome扩展工具去帮助你找出bug。
Vue与React最后一个相似但略有不同之处是它们配套框架的处理方法。相同之处在于，两个框架都专注于UI层，其他的功能如路由、状态管理等都交由同伴框架进行处理。
react
数据流单向
React推广了Virtual DOM，并创造了新的语法——JSX，JSX允许开发者在JavaScript中书写HTML
React一样由如Facebook这类大公司维护
props对于子组件来说是必须的，因为它依赖一个“单一数据源”作为它的“状态”
React可以使用Create React App (CRA)
而React的react-router和react-redux则是由社区成员维护，它们都不是官方维护的。
React与Vue最大的不同是模板的编写
在React中你需要使用setState()方法去更新状态
多数情况下，框架内置的状态管理是不足以支撑大型应用的，Redux或Vuex等状态管理方案是必须使用的。
vue
数据双向绑定
Vue使用模板系统而不是JSX，使其对现有应用的升级更加容易,这是因为模板用的就是普通的HTML，通过Vue来整合现有的系统是比较容易的，不需要整体重构
Vue主要是由一位开发者进行维护的
而在Vue中，props略有不同。它们一样是在组件中被定义，但Vue依赖于模板语法，你可以通过模板的循环函数更高效地展示传入的数据。
Vue对应的则是vue-cli
Vue的核心团队维护着vue-router和vuex
React与Vue最大的不同是模板的编写
在Vue中，state对象并不是必须的，数据由data属性在Vue对象中进行管理。
Vue的）解决方案适用于小型应用，但对于对于大型应用而言不太适合。
```

##### 5.`Vue3.0`是如何实现代码逻辑复用的？

```
Mixins有命名冲突，隐式依赖的问题

1.代码提取
相比Composition API的第一个明显优点是提取逻辑很容易。
2.代码重用
要在组件中使用该函数，我们只需将模块导入组件文件并调用它（注意导入是一个函数）。
3.命名冲突解决了
我们之前已经了解了mixin如何使用与消费者组件中的名称相同的属性，或者甚至更隐蔽地使用了消费者组件使用的其他mixin中的属性。
4.隐式依赖...解决了！
前面还看到mixin如何使用在消费组件上定义的 data 属性，这可能会使代码变得脆弱，并且很难进行推理。
```

# 8.移动端、小程序面试题

#### 1. 移动端兼容适配

```
<meta name="viewport" content="width=device-width, initial-scale=1.0">
•	rem, em, 百分比
•	框架的栅格布局
•	media query媒体查询
•	手淘团队的一套flexible.js, 自动判断dpr进行整个布局视口的放缩
```

#### 2.flexible如何实现自动判断dpr

```
判断机型, 找出样本机型去适配. 比如iphone以6为样本, 宽度375px, dpr是2
```

#### 3.为什么以iPhone6为标准的设计稿的尺寸是以750px宽度来设计的呢？

```
iPhone6的满屏宽度是375px，而iPhone6采用的视网膜屏的物理像素是满屏宽度的2倍，也就是dpr(设备像素比)为2, 并且设计师所用的PS设计软件分辨率和像素关系是1:1。所以为了做出的清晰的页面，设计师一般给出750px的设计图，我们再根据需求对元素的尺寸设计和压缩。
```

#### 4.如何处理异形屏iphone X

```
safe area: 默认放置在安全区域以避免遮挡, 但会压缩
•	在meta中添加viewport-fit=cover: 告诉浏览器要讲整个页面渲染到浏览器中，不管设备是圆角与否，这个时候会造成页面的元素被圆角遮挡
•	padding: constant(env): 解决遮挡问题
```

#### 5.移动端首屏优化

```
采用服务器渲染ssr
按需加载配合webpack分块打包, 通过entry和commonChunkPlugin
很有必要将script标签➕异步
有轮播图 最好给个默认 另外要处理图片懒加载
打包线上也要注意去掉map 文件
组件, 路由懒加载
webpack的一切配置 肯定是必须的
压缩图片 https://tinypng.com/ 
建议还是用webpack的图片压缩插件
骨架屏
Loading页面
```

#### 6.PWA全称Progressive Web App，即渐进式WEB应用 

```
一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能
解决了哪些问题？
•	可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏
•	实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能
•	实现了消息推送
它解决了上述提到的问题，这些特性将使得 Web 应用渐进式接近原生 App。
```

#### 7.离线包方案

```
现在 web 页面在移动端的地位越来越高，大部分主流 App 采用 native + webview 的 hybrid 模式，加载远程页面受限于网络，本地 webview 引擎，经常会出现渲染慢导致的白屏现象，体验很差，于是离线包方案应运而生。动态下载的离线包可以使得我们不需要走完整的 App 审核发布流程就完成了版本的更新
```

#### 8. 自适应和响应式布局的区别

```
1.	自适应布局通过检测视口分辨率，来判断当前访问的设备是：pc端、平板、手机，从而请求服务层，返回不同的页面；响应式布局通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。
2.	自适应布局需要开发多套界面，而响应式布局只需要开发一套界面就可以了。
3.	自适应对页面做的屏幕适配是在一定范围：比如pc端一般要大于1024像素，手机端要小于768像素。而响应式布局是一套页面全部适应。
4.	自适应布局如果屏幕太小会发生内容过于拥挤。而响应式布局正是为了解决这个问题而衍生出的概念，它可以自动识别屏幕宽度并做出相应调整的网页设计。
```

#### 9.简单描述下微信小程序的相关文件类型？

```
微信小程序项目结构主要有一下几个文件类型,如下
1、WXML （WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构
建出页面的结构。内部主要是微信自己定义的一套组件。
2、WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，
3、js 逻辑处理，网络请求
4、json 小程序设置，如页面注册，页面标题及 tabBar。
5、app.json 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文
件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的 window 背景色，配置导航
条样式，配置默认标题。
6、app.js 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我
们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。

```

#### 10.你是怎么封装微信小程序的数据请求的？

```
1、 将所有的接口放在统一的 js 文件中并导出
2、在 app.js 中创建封装请求数据的方法
3、在子页面中调用封装的方法请求数据

```

#### 11.小程序有哪些参数传值的方法？

```
1、给 HTML 元素添加 data-*属性来传递我们需要的值，然后通过 e.currentTarget.dataset 或 onload 的
param 参数获取。但 data-名称不能有大写字母和不可以存放对象
2、设置 id 的方法标识来传值通过 e.currentTarget.id 获取设置的 id 的值,然后通过设置全局对象的方式来
传递数值
3、在 navigator 中添加参数传值

```

#### 12.简述微信小程序原理？

```
1、微信小程序采用 JavaScript、WXML、WXSS 三种技术进行开发，从技术讲和现有的前端开发差不多，
但深入挖掘的话却又有所不同。
2、JavaScript：首先 JavaScript 的代码是运行在微信 App 中的，并不是运行在浏览器中，因此一些 H5 技
术的应用，需要微信 App 提供对应的 API 支持，而这限制住了 H5 技术的应用，且其不能称为严格的 H5，
可以称其为伪 H5，同理，微信提供的独有的某些 API，H5 也不支持或支持的不是特别好。
3、WXML：WXML 微信自己基于 XML 语法开发的，因此开发时，只能使用微信提供的现有标签，HTML
的标签是无法使用的。
4、WXSS：WXSS 具有 CSS 的大部分特性，但并不是所有的都支持，而且支持哪些，不支持哪些并没有
详细的文档。
5、微信的架构，是数据驱动的架构模式，它的 UI 和数据是分离的，所有的页面更新，都需要通过对数
据的更改来实现。
6、小程序分为两个部分 webview 和 appService。其中 webview 主要用来展现 UI，appService 有来处理
业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层 JSBridge 实现通信，实现 UI 的渲染、事
件的处理。


```

#### 13.小程序的双向绑定和 vue 哪里不一样？

```
小程序直接 this.data 的属性是不可以同步到视图的，必须调用：
小程序：
Page({
    data: {
    items: []
    },
    onLoad: function(options) {
    this.setData({
    items: [1,2,3]
    })
    }})
    Vue：
    new Vue({
    data: {
    items: []
    },
    mounted () {
    this.items = [1, 2, 3]
}})

```

#### 14.webview 中的页面怎么跳回小程序中？

```
<web-view/>网页中可使用 JSSDK 1.3.2 提供的接口返回小程序页面。
例如：wx.miniProgram.navigateTo({url: '/path/to/page'})

```

#### 15.小程序关联微信公众号如何确定用户的唯一性？

```
使用 wx.getUserInfo 方法 withCredentials 为 true 时可获取 encryptedData，里面有 union_id。后端需要进行
对称解密。

```

#### 16.小程序如何实现下拉刷新？

```
用 view 代替 scroll-view,,设置 onPullDownRefresh 函数实现。
1、在 json 文件中配置 enablePullDownRefresh 为 true(app.json 中在 window 中设置 enablePullDownRefresh,
此效果作用于全局)。
2、在 js 文件中实现 onPullDownRefresh 方法,在网络请求完成后调用 wx.stopPullDownRefresh()来结束下拉刷
新。

```

#### 17.小程序调用后台接口遇到哪些问题？

```
1、数据的大小有限制，超过范围会直接导致整个小程序崩溃，除非重启小程序；
2、小程序不可以直接渲染文章内容页这类型的 html 文本内容，若需显示要借住插件，但插件渲染会导致
页面加载变慢，所以最好在后台对文章内容的 html 进行过滤，后台直接处理批量替换 p 标签 div 标签为 view 标
签，然后其它的标签让插件来做，减轻前端的时间。

页面加载变慢，所以最好在后台对文章内容的 html 进行过滤，后台直接处理批量替换 p 标签 div 标签为 view 标
签，然后其它的标签让插件来做，减轻前端的时间。

```

#### 18.小程序的 wxss 和 css 有哪些不一样的地方？

```
1、wxss 的图片引入需使用外链地址。
2、没有 Body，样式可直接使用 import 导入。

```

#### 19.分析下微信小程序的优劣势

```
优 势：
1、无需下载，通过搜索和扫一扫就可以打开。
2、良好的用户体验：打开速度快。
3、开发成本要比 App 要低
4、安卓上可以添加到桌面，与原生 App 差不多。
5、为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程， 不能通过审查的小程序
是无法发布到线上的。
劣势：
1、限制较多。页面大小不能超过 1M。不能打开超过 5 个层级的页面。
2、样式单一。小程序的部分组件已经是成型的了，样式不可以修改。例如：幻灯片、导航。
3、推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的
限制。
4、依托于微信，无法开发后台管理功能。


```



# 9.es6面试题

## **1、var、let、const之间的区别**

> var声明变量可以重复声明，而let不可以重复声明
> var是不受限于块级的，而let是受限于块级
> var会与window相映射（会挂一个属性），而let不与window相映射
> var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错
> const声明之后必须赋值，否则会报错
> const定义不可变的量，改变了就会报错
> const和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错

## **2、使用箭头函数应注意什么？** 

> （1）用了箭头函数，this就不是指向window，而是父级（指向是可变的）
> （2）不能够使用arguments对象
> （3）不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误
> （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数

## **3、ES6的模板字符串有哪些新特性？并实现一个类模板字符串的功能**

> 基本的字符串格式化。
> 将表达式嵌入字符串中进行拼接。
> 用${}来界定在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。
> ES6反引号(``)就能解决类模板字符串的功能

```js
let name = 'web';
let age = 10;
let str = '你好，${name} 已经 ${age}岁了'
str = str.replace(/\$\{([^}]*)\}/g,function(){
     return eval(arguments[1]);
   })
console.log(str);//你好，web 已经 10岁了
```

## **4、介绍下 Set、Map的区别？**

> 应用场景Set用于数据重组，Map用于数据储存
>
> Set：　
> （1）成员不能重复
> （2）只有键值没有键名，类似数组
> （3）可以遍历，方法有add, delete,has
> Map:
> （1）本质上是健值对的集合，类似集合
> （2）可以遍历，可以跟各种数据格式转换

## **5、ECMAScript 6 怎么写 class ，为何会出现 class？**

> ES6的class可以看作是一个语法糖，它的绝大部分功能ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法

```js
//定义类
class Point { 
  constructor(x,y) { 
      //构造方法
       this.x = x; //this关键字代表实例对象
       this.y = y; 
  } toString() {
       return '(' + this.x + ',' + this.y + ')'; 
  }
}
```

## **6、Promise构造函数是同步执行还是异步执行，那么 then 方法呢？**

> promise构造函数是同步执行的，then方法是异步执行的

## **7、setTimeout、Promise、Async/Await 的区别**

> 事件循环中分为宏任务队列和微任务队列
> 其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行async函数表示函数里面可能会有异步方法，await后面跟一个表达式
> async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行

## **8、promise有几种状态，什么时候会进入catch？**

> 三个状态：
> pending、fulfilled、reject
> 两个过程：
> padding -> fulfilled、padding -> rejected当pending为rejectd时，会进入catch

## **9、下面的输出结果是多少**

```js
const promise = new Promise((resolve, reject) => {
    console.log(1);
    resolve();
    console.log(2);
})
promise.then(() => {
    console.log(3);
})
console.log(4);
```

> Promise 新建后立即执行，所以会先输出 1，2，而 Promise.then()内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3

## **10、使用结构赋值，实现两个变量的值的交换**

```js
let a = 1;let b = 2;
[a,b] = [b,a];
```

## **11、设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key**

```js
let name = Symbol('name');
 let product = {
    [name]:"洗衣机",    
    "price":799
  };
  Reflect.ownKeys(product);
```

## **12、下面Set结构，打印出的size值是多少**

```js
let s = newSet();
s.add([1]);s.add([1]);
console.log(s.size);
```

> 答案：2
> 两个数组[1]并不是同一个值，它们分别定义的数组，在内存中分别对应着不同的存储地址，因此并不是相同的值都能存储到Set结构中，所以size为2

## **13、Promise 中reject 和 catch 处理上有什么区别**

> reject 是用来抛出异常，catch 是用来处理异常
> reject 是 Promise 的方法，而 catch 是 Promise 实例的方法
> reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch
> 网络异常（比如断网），会直接进入catch而不会进入then的第二个回调



## **14、如何使用Set去重**

```js
let arr = [12,43,23,43,68,12];
let item = [...new Set(arr)];
console.log(item);//[12, 43, 23, 68]
```

## **15、将下面for循环改成for of形式**

```js
let arr = [11,22,33,44,55];
let sum = 0;
for(let i=0;i<arr.length;i++){
    sum += arr[i];
}
```

> 答案：

```js
let arr = [11,22,33,44,55];
let sum = 0;
for(value of arr){
    sum += value;
}
```

## **16、理解 async/await以及对Generator的优势**

> async await 是用来解决异步的，async函数是Generator函数的语法糖
> 使用关键字async来表示，在函数内部使用 await 来表示异步
> async函数返回一个 Promise 对象，可以使用then方法添加回调函数
> 当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句
> **async较Generator的优势：**
> （1）内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样
> （2）更好的语义。async 和 await 相较于 * 和 yield 更加语义化　　
> （3）更广的适用性。yield命令后面只能是 Thunk 函数或 Promise对象，async函数的await后面可以是Promise也可以是原始类型的值
> （4）返回值是 Promise。async 函数返回的是 Promise 对象，比Generator函数返回的Iterator对象方便，可以直接使用 then() 方法进行调用

## **17、forEach、for in、for of三者区别**

> forEach更多的用来遍历数组
> for in 一般常用来遍历对象或json
> for of数组对象都可以遍历，遍历对象需要通过和Object.keys()
> for in循环出的是key，for of循环出的是value

## **28、说一下es6的导入导出模块**

> 导入通过import关键字

```js
// 只导入一个
import {sum} from "./example.js"
// 导入多个
import {sum,multiply,time} from "./exportExample.js"
// 导入一整个模块
import * as example from "./exportExample.js"
```

> 导出通过export关键字

```js
//可以将export放在任何变量,函数或类声明的前面
export var firstName = 'Michael';
export var lastName = 'Jackson';
export var year = 1958;
//也可以使用大括号指定所要输出的一组变量
var firstName = 'Michael';
var lastName = 'Jackson';
var year = 1958;
export {firstName, lastName, year};
//使用export default时，对应的import语句不需要使用大括号
let bosh = function crs(){}
export default bosh;
import crc from 'crc';
//不使用export default时，对应的import语句需要使用大括号
let bosh = function crs(){}
export bosh;
import {crc} from 'crc';
```

# 10.React面试题

1. react组件如何通信

   - 父组件向子组件通信：使用 props
   - 子组件向父组件通信：使用 props 回调
   - 跨级组件间通信：使用 context 对象
   - 非嵌套组件间通信：使用事件订阅

2. jsx本质是什么

   jsx其实是语法糖，开发环境会将jsx编译成js代码，jsx的写法大大降低了学习成本和编码工作量

3. context是什么，有何用途

   在react应用中，数据总是通过 props 自上而下进行传递。 这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI 主题）。**Context 可以共享对于一个组件树而言是“全局”的数据。这样就不必显式地通过组件树的逐层传递 props**

4. shouldComponentUpdate用途

   询问组件是否需要更新的一个钩子函数，判断数据是否需要重新渲染，返回一个布尔值。默认的返回值是true，需要重新render()。若如果返回值是false则不触发渲染,利用这个生命周期函数可以强制关闭不需要更新的子组件来提升渲染性能。
   这个方法用来判断是否需要调用 render 方法重新描绘 dom。
   因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。

5. 描述redux单项数据流

   当一个页面渲染完后，UI出现，用户其实是触发了UI上的一些Action，Action将会被送到Reducers方法里，Reducers将会更新Store，数据就是React开发中的State，State其实是Store的一部分，所有的视图层的东西，也就是组件，其实是由State来唯一决定的。

   ![img](D:\课件\课件p4\day06 React\img\Center)

6. setState是同步还是异步？

   既可能是同步的,也可能是异步的。 准确地说,在React内部机制能检测到的地方, setState就是异步的;在React检测不到的地方,例如setInterval,setTimeout里,setState就是同步更新的

7. 什么是纯函数

   一个函数的返回结果只依赖其参数，并且执行过程中没有副作用。

8. react组件生命周期

   // 实例化组件，也就是构造DOM元素
   constructor();
   // 当DOM元素载入之前调用
   componentWillMount();
   // 将构造的元素插入到指定的页面元素中
   render();
   // 当DOM元素载入页面之后调用
   componentDidMount();
   // 当从页面中卸载时会调用
   componentWillUnmount()

9. react发起ajax应该在哪个生命周期

   componentDidMount生命周期中调用

10. 渲染列表，为何使用key？

    key是给每一个虚拟dom的唯一id,可以依靠key,更准确, 更快的拿到旧虚拟dom中对应的新虚拟dom节点。

11. 函数组件和class组件区别

    函数组件纯函数，输入props，输出jsx

    函数组件没有实例，没有生命周期，没有state

    函数组件不能扩展其他方法

    class创建的组件,有自己的私有数据(this.state)和生命周期 

12. 什么是受控组件

    简单的说就是input里面的值受state值控制

13. 何时使用异步组件

     加载大组件  路由异步加载  资源异步加载

14. 多个组件有公共逻辑，如何抽离

    - `HOC`，高阶组件   高阶组件不是一种功能，而是一种模式
    - `Render Props`核心思想：通过一个函数将class组件的state作为props传递给纯函数组件

15. redux如何进行异步请求 ajax请求

    ```dart
    1.在actionType中添加异步数据需要的action类型
     export const INIT_TODO_ITEM = 'init_todo_item'
    ```

    ```tsx
    2.在actionCreator中添加生成action的函数
    export const getInitTodoItemAction = (list) => ({
        type: INIT_TODO_ITEM,
        list
    })
    ```

    ```jsx
    3.在容器组件的ComponentDidMount中发送ajax请求，并生成和发送action
    componentDidMount(){
        axios.get('/getData').then(function(res){
          const action = getInitTodoItemAction(res.data)
          store.dispatch(action)
        })
    }
    ```

    ```cpp
    4.在reducer中添加处理action的方法
    if(action.type === INIT_TODO_ITEM){
        newState.list = action.list
        return newState 
    }
    ```

16. react-router如何配置懒加载

    lazyload-loader方式     `import Shop from 'lazy!./src/view/Shop';`

    箭头函数方式 `component:resolve => require(['@/component/Login'],resolve)`·

17. PureComponent和Component有何区别

    React.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过props和state的浅对比来实现 shouldComponentUpate()。

    在PureComponent中，如果包含比较复杂的数据结构，可能会因深层的数据不一致而产生错误的否定判断，导致界面得不到更新。

18. react事件和dom事件区别

    ```
      1. event 是 SyntheticEvent 组合事件对象，模拟出来 DOM 事件所有能力
      2. event.nativeEvent 是原生事件对象
      3. 所有的事件，都被挂载到 document 上，为了性能
      4. 和 DOM 事件不一样，和 Vue 事件也不一样
    ```

19. react性能优化

    使用shouldComponentUpdate来优化组件

    shouldComponentUpdate的实现方式，shouldComponentUpdate在比对prop和上次渲染所用的prop方面，依然用的是尽量简单的方法，做的是所谓的“浅层比较”。简单来说就是用JavaScript的===操作符来比较，如果prop的类型是字符串或者数字，只要值相同，那么“浅层比较”也会认为二者相同，但是，如果prop的类型是复杂对象，那么“浅层比较”的方式只看这两个prop是不是同一个对象的引用，如果不是，哪怕这两个对象中的内容完全一样，也会被认为是两个不同的prop。

20. react和vue区别

    ```
    1、vue是响应式的数据双向绑定系统，而react是单向数据流，没有双向绑定。
    2、vue的语法较为简单，适用于小型项目创建，而react更适用于Web端和原生App的开发，侧重于大型应用。
    3、vue拥有更快的渲染速度和更小的体积，react则拥有更大的生态圈，可以带来更多的工具支持。
    4、模板渲染方式的不同
    在表层上，模板的语法不同，React是通过JSX渲染模板。而Vue是通过一种拓展的HTML语法进行渲染，但其实这只是表面现象，毕竟React并不必须依赖JSX。
    
    在深层上，模板的原理不同，这才是他们的本质区别：React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的，更加纯粹更加原生。而Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现对这一点，这样的做法显得有些独特，会把HTML弄得很乱。
    ```




# 11.面试实战

1.promise封装ajax？

```
// Promise 封装 ajax
function fetch(method, url, data){  //1.
    return new Promise((resolve, reject) => { //2.
        var xhr = new XMLHttpRequest();//3.
        var method = method || "GET";
        var data = data || null;
        xhr.open(method, url, true);//4.
        xhr.send(data);//post请求发送数据
        xhr.onreadystatechange = function() {//5.
            if(xhr.status === 200 && xhr.readyState === 4){
                resolve(xhr.responseText);
            } else {
                reject(xhr.responseText);
            }
        }
        
     })
}
// 使用
fetch("GET", "/some/url.json", null)
.then(result => {
    console.log(result);
})
```

2.移动端1像素问题如何解决

```
移动端 1px 像素问题及解决办法
前言：在移动端web开发中，UI设计稿中设置边框为1像素，前端在开发过程中如果出现border:1px，测试会发现在某些机型上，1px会比较粗，即是较经典的 移动端1px像素问题。
解决办法
 @media screen and (-webkit-min-device-pixel-ratio: 2) {
     .border { border: 0.5px solid #ccc }
 }
 @media screen and (-webkit-min-device-pixel-ratio: 3) {
     .border { border: 0.333333px solid #ccc }
}
使用transform:scaleY
.line{
     width: 100%;
     height: 1px;
     background-color: black;
     margin-top: 100px;
     transform: scaleY(0.33333);
     transform-origin: 0 0;
 }
```

3.如何解决vuex刷新之后数据重置的问题 

```
由于vuex是保存在内存中的所以每次页面刷新数据都会被重置，相当于重新加载js代码。
方法一：利用beforeunload事件在用户刷新页面时将vuex的store存入sessionstorage中然后再在页面加载时获从sessionstorage中获取,replaceState  store，然后清除
方法二：也是我研究iview-admin时总结出来的方法。登入时保存token在cookie中，store中保存的token用函数指向这个cookie，再路由守卫中做控制当token存在但却没有用户信息时调用获取用户信息的actiion方法为store中的用户信息重新赋值，也就是在每次刷新页面时都会重新请求一遍用户信息
```

4.git常用命令

```
Git常用操作命令：
1) 远程仓库相关命令
检出仓库：$ git clone git://github.com/jquery/jquery.git
查看远程仓库：$ git remote -v
添加远程仓库：$ git remote add [name] [url]
删除远程仓库：$ git remote rm [name]
修改远程仓库：$ git remote set-url --push [name] [newUrl]
拉取远程仓库：$ git pull [remoteName] [localBranchName]
推送远程仓库：$ git push [remoteName] [localBranchName]
2）分支(branch)操作相关命令
查看本地分支：$ git branch
查看远程分支：$ git branch -r
创建本地分支：$ git branch [name] ----注意新分支创建后不会自动切换为当前分支
切换分支：$ git checkout [name]
创建新分支并立即切换到新分支：$ git checkout -b [name]
删除分支：$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项
合并分支：$ git merge [name] ----将名称为[name]的分支与当前分支合并
创建远程分支(本地分支push到远程)：$ git push origin [name]
删除远程分支：$ git push origin :heads/[name] 或 $ gitpush origin :[name] 
```

5.promise原理

```
promise原理实现
基于上面的应用场景发现promise可以有三种状态，分别是pedding 、Fulfilled、 Rejected。
Pending Promise对象实例创建时候的初始状态
Fulfilled 可以理解为成功的状态
Rejected可以理解为失败的状态
·构造一个Promise实例需要给Promise构造函数传入一个函数。传入的函数需要有两个形参，两个形参都是function类型的参数。分别是resolve和reject。
·Promise上还有then方法，then 方法就是用来指定Promise 对象的状态改变时确定执行的操作，resolve 时执行第一个函数（onFulfilled），reject时执行第二个函数（onRejected）
·当状态变为resolve时便不能再变为reject，反之同理。
```

6.router和localhost.href和go(-1)

```
①vue-router使用pushState进行路由更新，静态跳转，页面不会重新加载；location.href会触发浏览器，页面重新加载一次
②vue-router使用diff算法，实现按需加载，减少dom操作
③vue-router是路由跳转或同一个页面跳转；location.href是不同页面间跳转；
④vue-router是异步加载this.$nextTick(()=>{获取url})；location.href是同步加载
location.href可直接获取当前路径
```

7.css动态效果

```
css3动画属性有哪些
transition ：   平衡过渡
animation： 动画
transform： 改变元素的大小、位置 

https://www.w3cschool.cn/css3/css3-qs8z2oq9.html
1、CSS3和SVG文字背景动画，超酷的文字特效
2、CSS3下划线跟随动画菜单，背景色渐变
3、CSS3手势变换动画特效
4、基于Bootstrap的CSS3面包屑菜单
5、纯CSS3实现圆盘时钟动画
6、HTML5/CSS3 3D下拉折叠菜单 3D子菜单
7、动感的CSS3 Loading文字特效
```

8.vue框架搭建

```
https://www.cnblogs.com/GeniusZ/p/12531027.html
初始化项目
修改目录结构
多环境运行
axios封装
模块化vuex
全局引用样式
移动端适配配置
常用util
引入第三方UI框架
配置vue.config.js文件
vue项目框架性能优化（重点）
	js,css代码的最小化压缩和分割
    js,css代码公用代码提取, 按需引入(cdn加载)
    图片文件的压缩
    gzip的压缩
    去除console.log
```

9.前端上百万的点，加载会崩溃，有啥性能优化方案？

```

分页分表，比如前端可以把数据分页展示，后端也分段吐数据从渲染上解决：
异步渲染，比如进入页面先不渲染，然后加载好页面再渲染。
局部渲染：只渲染目前可见区域的数据，再渲染次屏数据。
还有性能瓶颈，可以考虑web worker 做压缩和解码，也可以考虑离屏canvas做预渲染。
减少网络耗时：压缩数据，gzip等

```

10,说下云计算？

```
云计算，有这么几大类：
云主机，云应用，云存储等。
云主机，目前经常dao见到的是云桌面，就是在互联网上，或者企业云环境上，有一些虚拟的电脑，你通过终端登录到这些虚拟电脑上，这些虚拟的电脑给你呈现了一个跟普通电脑一样的启动画面，进入windows、linux或其它操作系统，你可以象用自己的电脑一样在上面装应用，办公。
举例：eyeos
云应用，简单理解，就是有在互联网上有一些应用，这些应用可以通过浏览器、客户端等操作，数据放在互联网上，用目前经常用的是办公、事务管理类的应用，比如office365，云便签等。云应用可以在任意地点通过多种方式访问。
举例：evernote
云存储，广泛意义上的云存储范围非常大，但是常见的云存储实际上很多人都在用了，简单理解就是互联网上放了一块逻辑上归属于你的硬盘，比如百度云的云盘上面可以存放文件、视频什么的。
举例：百度云、360云盘、腾讯微云、新浪微盘
```

11.ajax和axios的区别

```
axios是通过promise实现对ajax技术的一种封装，就像jQuery实现ajax封装一样。
简单来说： ajax技术实现了网页的局部数据刷新，axios实现了对ajax的封装。
```

12.在vue中如何监听对象obj.a

```
watch: {
    obj.a:{
        handler(new_value,old_value){
            console.log(new_value,old_value)
        },
        deep: true
    }
}
```

13.在vue中如何给属性动态添加新属性

```
在组件上添加属性 this.$set(this.data,"obj",value');
删除属性this.$delete(this.data,"obj",value');
```

14.简单描述nextTick原理及作用

```
1.异步说明
Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。
2.事件循环说明
简单来说，Vue在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。
作用：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。
```

15.如何解决弹性盒布局div会随内部表格被撑开的问题。

```
弹性布局时div被内容撑开导致变形,直接将内容width or height 设为0;
```

16.兼容pc端移动端响应式页面，pc端左右轮播，移动端上下轮播实现

```
https://blog.csdn.net/kzj0916/article/details/108164259
一，通过媒体查询实现响应式（@media）
优点：适用于小型网页，用户交互较少的项目，代码用量较少；
缺点：在页面内容过多，用户交互过多的时候，如果通过 @media 来一个个改的话，那代码量可就很多了，而且也不方便维护。因此需要另一种方式来解决这个问题。

二，通过判断打开设备的类型，区分需要显示的方式和界面
 //App.vue
  mounted() {
      if (this._isMobile()) {
        alert("手机端");
        // this.$router.replace('/m_index');
      } else {
        alert("pc端");
        // this.$router.replace('/pc_index');
      }
    },
    methods: {
      //App.vue
      _isMobile() {
        let flag = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)
        return flag;
      }
  }
```



# 12.项目话术

```
公司名称
公司地址
标志建筑物
交通
项目描述
我的职责
印象深刻的事
离职原因
开发中遇到的问题，如何解决
团队人员
功能介绍
```



 
